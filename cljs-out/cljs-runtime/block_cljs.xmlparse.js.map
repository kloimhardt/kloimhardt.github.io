{"version":3,"sources":["block_cljs/xmlparse.cljs"],"mappings":"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","names":["block-cljs.xmlparse/l-block","x","type","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","s","t","u","p1__31197#","cljs.core.map.cljs$core$IFn$_invoke$arity$2","c","cljs.core.take.cljs$core$IFn$_invoke$arity$2","cljs.core/count","pred__31198","expr__31199","cljs.core/=","cljs.core.subs.cljs$core$IFn$_invoke$arity$3","block-cljs.xmlparse/level1b","cljs.core/map?","G__31203","fexpr__31202","a","p1__31201#","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.mapv.cljs$core$IFn$_invoke$arity$2","b","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/empty?","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core.into.cljs$core$IFn$_invoke$arity$2","block-cljs.xmlparse/level2a","cljs.core/first","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","block-cljs.xmlparse/level3a","and__4174__auto__","cljs.core/last","cljs.core/vec","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","cljs.core/butlast","block-cljs.xmlparse/level4a","cljs.core.symbol.cljs$core$IFn$_invoke$arity$1","cljs.core/contains?","temp__5733__auto__","cljs.core/cons","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/list","v","cljs.core.partition.cljs$core$IFn$_invoke$arity$2","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","cljs.core/assoc","cljs.core.interleave.cljs$core$IFn$_invoke$arity$2","cljs.core/symbol","block-cljs.xmlparse/parse","edn"],"sourcesContent":["(ns block-cljs.xmlparse)\n\n(defn l-block [x]\n  (let [type (get-in x [:attributes :type])\n        s (get-in x [:content 0 :content 0])\n        t (get-in x [:content 1 :content 0])\n        u (map #(get-in % [:content 0])\n               (let [c (get-in x [:content])] (take (/ (count c) 2) c)))]\n    (condp = (subs (str type \"___\") 0 4)\n      \"vari\" {:var s} ;;\"variables_get\"\n      \"num_\" {:num s}\n      \"sym_\" {:sym s}\n      \"text\" {:text s}\n      \"funs\"  {:fun s}\n      \"inli\" {:inli s}\n      \"list\" {:list s}\n      \"idfu\" {:idfun [s t]}\n      \"pair\" {:pair \"p\"}\n      \"map_\" {:map \"m\"}\n      \"map-\" {:map-h u}\n      \"vect\" {:vec \"v\"}\n      \"let_\" {:let \"l\"}\n      \"args\" {:args \"args\"}\n      {})))\n\n;;generate EDN with the keywords coded in l-block + :dat\n(defn level1b [x]\n  (if (map? x)\n    (if (#{:block :xml :value :next :statement} (:tag x))\n      (let [a (filter #(not= {} %) (mapv level1b (:content x)))\n            b (if (= :block (:tag x)) (l-block x) {})]\n        (if (empty? a) b (assoc b :dat (into [] a))))\n      {})\n    x))\n\n;;delete empty nodes in the middle of tree\n(defn level2a [x]\n  (let [a (mapv level2a (:dat x))]\n    (if (and (= 1 (count x)) (= 1 (count a)))\n      (first a)\n      (if (empty? a)\n        (dissoc x :dat)\n        (assoc x :dat a)))))\n\n;;unnest pairs, make defn argument vector\n(defn level3a [x]\n  (let [a (mapv level3a (:dat x))]\n    (if (empty? a)\n      (dissoc x :dat)\n      (cond\n        (and (:pair x) (:pair (last a)))\n        (assoc x :dat (vec (concat (butlast a) (:dat (last a)))))\n        (and (= (:fun x) \"defn\") (:var (a 1)))\n        (assoc x :dat [(a 0) {:args \"args-1\" :dat [(a 1)]} (a 2)])\n        (and (= (:fun x) \"fn\") (:var (a 0)))\n        (assoc x :dat [{:args \"args-1\" :dat [(a 0)]} (a 1)])\n        :else (assoc x :dat a)))))\n\n(defn level4a [x] ;;generate code\n  (let [a (mapv level4a (:dat x))]\n    (cond\n      (:var x) (symbol (:var x))\n      (:num x) (symbol (:num x))\n      (:sym x) (symbol (:sym x))\n      (contains? x :text) (if-let [t (:text x)] t \" \")\n      (:fun x) (cons (symbol (:fun x)) a)\n      (:inli x) (cons (symbol (:inli x)) a)\n      (:list x) (apply list a)\n      (:idfun x) (let [v (:idfun x)] (cons (symbol (v 0)) (cons (v 1) a)))\n      (:pair x) a\n      (:map x) (into {} (map vec (partition 2 (first a))))\n      (:map-h x) (apply assoc {} (interleave (map symbol (:map-h x)) a))\n      (:vec x) (first a)\n      (:let x) (cons 'let a)\n      (:args x) a\n      (empty? a) (dissoc x :dat)\n      :else  (assoc x :dat a))))\n\n(defn parse [edn]\n  (-> edn\n      level1b\n      level2a\n      level3a\n      level4a))\n"]}