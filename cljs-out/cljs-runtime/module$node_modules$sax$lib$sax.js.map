{
"version":3,
"file":"module$node_modules$sax$lib$sax.js",
"lineCount":46,
"mappings":"AAAAA,cAAA,gCAAA,CAAoD,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAC5F,IAAIC,OAASH,OAAA,CAAQ,kCAAR,CAAAG,OACX,UAAS,CAACC,GAAD,CAAM,CA4CfC,QAASA,UAAU,CAACC,MAAD,CAASC,GAAT,CAAc,CAC/B,GAAI,EAAE,IAAF,WAAkBF,UAAlB,CAAJ,CACE,MAAO,KAAIA,SAAJ,CAAcC,MAAd,CAAsBC,GAAtB,CAyFT,KAD6B,IACpBC,EAAI,CADgB,CACbC,EAAIC,OAAAC,OAApB,CAAoCH,CAApC,CAAwCC,CAAxC,CAA2CD,CAAA,EAA3C,CAtFaI,IAuFX,CAAOF,OAAA,CAAQF,CAAR,CAAP,CAAA,CAAqB,EAvFVI,KAEbC,EAAA,CAFaD,IAEFE,EAAX,CAAsB,EAFTF,KAGbG,oBAAA,CAA6BX,GAAAY,kBAHhBJ,KAIbL,IAAA,CAAaA,GAAb,EAAoB,EAJPK,KAKbL,IAAAU,UAAA,CALaL,IAKUL,IAAAU,UAAvB,EALaL,IAKkCL,IAAAW,cALlCN,KAMbO,UAAA,CANaP,IAMML,IAAAU,UAAA,CAAuB,aAAvB;AAAuC,aAN7CL,KAObQ,KAAA,CAAc,EAPDR,KAQbS,OAAA,CARaT,IAQGU,WAAhB,CARaV,IAQuBW,QAApC,CAAqD,CAAA,CARxCX,KASbY,IAAA,CATaZ,IASAa,MAAb,CAA4B,IATfb,KAUbN,OAAA,CAAgB,CAAC,CAACA,MAVLM,KAWbc,SAAA,CAAkB,EAAGpB,CAAAA,MAAH,EAAaoB,CAXlBd,IAWkBL,IAAAmB,SAAb,CAXLd,KAYbe,MAAA,CAAeC,CAAAC,MAZFjB,KAcbkB,SAAA,CAAkB,CAdLlB,IAabmB,eACkB,CAdLnB,IAaWL,IAAAwB,eACN,EAAwBC,MAAAC,OAAA,CAAc7B,GAAA8B,aAAd,CAAxB,CAA0DF,MAAAC,OAAA,CAAc7B,GAAA0B,SAAd,CAd/DlB,KAebuB,WAAA,CAAoB,EAfPvB,KAoBTL,IAAA6B,MAAJ,GApBaxB,IAqBXyB,GADF,CACcL,MAAAC,OAAA,CAAcK,MAAd,CADd,CAMA,IA1Ba1B,IAyBb2B,cACA,CAD+C,CAAA,CAC/C,GA1Ba3B,IAyBUL,IAAAiC,SACvB,CA1Ba5B,IA2BX4B,SAAA,CA3BW5B,IA2BO6B,KAAlB,CA3BW7B,IA2BqB8B,OAAhC,CAAgD,CA3BrC9B,KA8jBb,QAAA,EA9jBaA,IA8jBI,QAAA,CAjiBjB+B,IAAA,EAiiBiB,CAnkBc,CAmIjCC,QAASA,UAAU,CAACtC,MAAD;AAASC,GAAT,CAAc,CAC/B,GAAI,EAAE,IAAF,WAAkBqC,UAAlB,CAAJ,CACE,MAAO,KAAIA,SAAJ,CAActC,MAAd,CAAsBC,GAAtB,CAGTsC,OAAAC,MAAA,CAAa,IAAb,CAEA,KAAAC,QAAA,CAAe,IAAI1C,SAAJ,CAAcC,MAAd,CAAsBC,GAAtB,CAEf,KAAAyC,SAAA,CADA,IAAAC,SACA,CADgB,CAAA,CAGhB,KAAIC,GAAK,IAET,KAAAH,QAAAI,MAAA,CAAqBC,QAAS,EAAG,CAC/BF,EAAAG,KAAA,CAAQ,KAAR,CAD+B,CAIjC,KAAAN,QAAAO,QAAA,CAAuBC,QAAS,CAACC,EAAD,CAAK,CACnCN,EAAAG,KAAA,CAAQ,OAAR,CAAiBG,EAAjB,CAIAN,GAAAH,QAAAtB,MAAA,CAAmB,IALgB,CAQrC,KAAAgC,SAAA,CAAgB,IAEhBC,YAAAC,QAAA,CAAoB,QAAS,CAACC,EAAD,CAAK,CAChC5B,MAAA6B,eAAA,CAAsBX,EAAtB,CAA0B,IAA1B,CAAiCU,EAAjC,CAAqC,CACnCE,IAAKA,QAAS,EAAG,CACf,MAAOZ,GAAAH,QAAA,CAAW,IAAX,CAAkBa,EAAlB,CADQ,CADkB,CAInCG,IAAKA,QAAS,CAACC,CAAD,CAAI,CAChB,GAAI,CAACA,CAAL,CAGE,MAFAd,GAAAe,mBAAA,CAAsBL,EAAtB,CACAI,CAAAd,EAAAH,QAAA,CAAW,IAAX,CAAkBa,EAAlB,CAAAI,CAAwBA,CAG1Bd,GAAAgB,GAAA,CAAMN,EAAN;AAAUI,CAAV,CANgB,CAJiB,CAYnCG,WAAY,CAAA,CAZuB,CAanCC,aAAc,CAAA,CAbqB,CAArC,CADgC,CAAlC,CA3B+B,CA8GjCC,QAASA,aAAa,CAACvD,CAAD,CAAI,CACxB,MAAa,GAAb,GAAOA,CAAP,EAA0B,IAA1B,GAAoBA,CAApB,EAAwC,IAAxC,GAAkCA,CAAlC,EAAsD,IAAtD,GAAgDA,CADxB,CAI1BwD,QAASA,QAAQ,CAACxD,CAAD,CAAI,CACnB,MAAa,GAAb,GAAOA,CAAP,EAA0B,GAA1B,GAAoBA,CADD,CAiVrByD,QAASA,SAAS,CAAC3D,MAAD,CAAS4D,QAAT,CAAmB7B,IAAnB,CAAyB,CACrC/B,MAAA6D,SAAJ,EAAqBC,SAAA,CAAU9D,MAAV,CAChBA,OALL,CAKa4D,QALb,CAAA,EAKK5D,MALY,CAKJ4D,QALI,CAAA,CAKM7B,IALN,CAGwB,CAK3C+B,QAASA,UAAU,CAAC9D,MAAD,CAAS,CAC1BA,MAAA6D,SAAA,CAAkBE,QAAA,CAAS/D,MAAAL,IAAT,CAAqBK,MAAA6D,SAArB,CACd7D,OAAA6D,SAAJ,EAA0B7D,MAV1B,OAUA,EAA0BA,MAVT,OAAA,CAU2BA,MAAA6D,SAV3B,CAWjB7D,OAAA6D,SAAA,CAAkB,EAHQ,CAM5BE,QAASA,SAAS,CAACpE,GAAD,CAAMqE,IAAN,CAAY,CACxBrE,GAAAsE,KAAJ,GAAcD,IAAd,CAAqBA,IAAAC,KAAA,EAArB,CACItE,IAAAuE,UAAJ,GAAmBF,IAAnB;AAA0BA,IAAAG,QAAA,CAAa,MAAb,CAAqB,GAArB,CAA1B,CACA,OAAOH,KAHqB,CAM9BnD,QAASA,MAAM,CAACb,MAAD,CAAS4C,EAAT,CAAa,CAC1BkB,SAAA,CAAU9D,MAAV,CACIA,OAAA2B,cAAJ,GACEiB,EADF,EACQ,UADR,CACqB5C,MAAA6B,KADrB,CAEI,YAFJ,CAEmB7B,MAAA8B,OAFnB,CAGI,UAHJ,CAGiB9B,MAAAE,EAHjB,CAKA0C,GAAA,CAASwB,KAAJ,CAAUxB,EAAV,CACL5C,OAAAa,MAAA,CAAe+B,EACV5C,OA7BL,QAAA,EA6BKA,MA7BY,QAAA,CA6BO4C,EA7BP,CA8BjB,OAAO5C,OAVmB,CAa5BqE,QAASA,IAAI,CAACrE,MAAD,CAAS,CAChBA,MAAAW,QAAJ,EAAsB,CAACX,MAAAU,WAAvB,EAA0C4D,UAAA,CAAWtE,MAAX,CAAmB,mBAAnB,CACrCA,OAAAe,MAAL,GAAsBC,CAAAC,MAAtB,EACGjB,MAAAe,MADH,GACoBC,CAAAuD,iBADpB,EAEGvE,MAAAe,MAFH,GAEoBC,CAAAwD,KAFpB,EAGE3D,KAAA,CAAMb,MAAN,CAAc,gBAAd,CAEF8D,UAAA,CAAU9D,MAAV,CACAA,OAAAE,EAAA,CAAW,EACXF,OAAAS,OAAA;AAAgB,CAAA,CACXT,OA3CL,MAAA,EA2CKA,MA3CY,MAAA,CA2CjB+B,IAAA,EA3CiB,CA4CjBtC,UAAAgF,KAAA,CAAezE,MAAf,CAAuBA,MAAAN,OAAvB,CAAsCM,MAAAL,IAAtC,CACA,OAAOK,OAZa,CAetBsE,QAASA,WAAW,CAACtE,MAAD,CAAS0E,OAAT,CAAkB,CACpC,GAAsB,QAAtB,GAAI,MAAO1E,OAAX,EAAkC,EAAEA,MAAF,WAAoBP,UAApB,CAAlC,CACE,KAAU2E,MAAJ,CAAU,wBAAV,CAAN,CAEEpE,MAAAN,OAAJ,EACEmB,KAAA,CAAMb,MAAN,CAAc0E,OAAd,CALkC,CAsBtCC,QAASA,MAAM,CAACC,IAAD,CAAOC,SAAP,CAAkB,CAE/B,IAAIC,SAAe,CAAJ,CADPF,IAAAG,QAAAnF,CAAa,GAAbA,CACO,CAAQ,CAAE,EAAF,CAAMgF,IAAN,CAAR,CAAuBA,IAAAI,MAAA,CAAW,GAAX,CAAtC,CACIC,OAASH,QAAA,CAAS,CAAT,CACTI,SAAAA,CAAQJ,QAAA,CAAS,CAAT,CAGRD,UAAJ,EAA0B,OAA1B,GAAiBD,IAAjB,GACEK,MACA,CADS,OACT,CAAAC,QAAA,CAAQ,EAFV,CAKA,OAAO,CAAED,OAAQA,MAAV,CAAkBC,MAAOA,QAAzB,CAZwB,CAejCC,QAASA,OAAO,CAACnF,MAAD,CAAS,CAClBA,MAAAN,OAAL;CACEM,MAAAoF,WADF,CACsBpF,MAAAoF,WAAA,CAAkBpF,MAAAO,UAAlB,CAAA,EADtB,CAIA,IAAsD,EAAtD,GAAIP,MAAAuB,WAAAwD,QAAA,CAA0B/E,MAAAoF,WAA1B,CAAJ,EACE,CAAApF,MAAAY,IAAAyE,WAAAC,eAAA,CAAqCtF,MAAAoF,WAArC,CADF,CAMA,GAAIpF,MAAAL,IAAA6B,MAAJ,CAAsB,CACpB,IAAI+D,GAAKZ,KAAA,CAAM3E,MAAAoF,WAAN,CAAyB,CAAA,CAAzB,CAAT,CAEIF,MAAQK,EAAAL,MAEZ,IAAe,OAAf,GAHaK,EAAAN,OAGb,CAEE,GAAc,KAAd,GAAIC,KAAJ,EAAuBlF,MAAAwF,YAAvB,GAA8CC,aAA9C,CACEnB,UAAA,CAAWtE,MAAX,CACE,+BADF,CACoCyF,aADpC,CACoD,YADpD,CAEezF,MAAAwF,YAFf,CADF,KAIO,IAAc,OAAd,GAAIN,KAAJ,EAAyBlF,MAAAwF,YAAzB,GAAgDE,eAAhD,CACLpB,UAAA,CAAWtE,MAAX,CACE,iCADF;AACsC0F,eADtC,CACwD,YADxD,CAEe1F,MAAAwF,YAFf,CADK,KAIA,CACD5E,EAAAA,CAAMZ,MAAAY,IACV,KAAI+E,OAAS3F,MAAAQ,KAAA,CAAYR,MAAAQ,KAAAT,OAAZ,CAAiC,CAAjC,CAAT4F,EAAgD3F,MAChDY,GAAAa,GAAJ,GAAekE,MAAAlE,GAAf,GACEb,EAAAa,GADF,CACWL,MAAAC,OAAA,CAAcsE,MAAAlE,GAAd,CADX,CAGAb,GAAAa,GAAA,CAAOyD,KAAP,CAAA,CAAgBlF,MAAAwF,YANX,CAaTxF,MAAAuB,WAAAqE,KAAA,CAAuB,CAAC5F,MAAAoF,WAAD,CAAoBpF,MAAAwF,YAApB,CAAvB,CA5BoB,CAAtB,IA+BExF,OAAAY,IAAAyE,WAAA,CAAsBrF,MAAAoF,WAAtB,CACA,CAD2CpF,MAAAwF,YAC3C,CAAA7B,QAAA,CAAS3D,MAAT,CAAiB,aAAjB,CAAgC,CAC9B4E,KAAM5E,MAAAoF,WADwB,CAE9BS,MAAO7F,MAAAwF,YAFuB,CAAhC,CApCAxF,OAAAoF,WAAA,CAAoBpF,MAAAwF,YAApB,CAAyC,EAPpB,CAoDzBM,QAASA,QAAQ,CAAC9F,MAAD,CAAS+F,WAAT,CAAsB,CACrC,GAAI/F,MAAAL,IAAA6B,MAAJ,CAAsB,CAEpB,IAAIZ;AAAMZ,MAAAY,IAAV,CAGI2E,GAAKZ,KAAA,CAAM3E,MAAAgG,QAAN,CACTpF,IAAAqE,OAAA,CAAaM,EAAAN,OACbrE,IAAAsE,MAAA,CAAYK,EAAAL,MACZtE,IAAAqF,IAAA,CAAUrF,GAAAa,GAAA,CAAO8D,EAAAN,OAAP,CAAV,EAA+B,EAE3BrE,IAAAqE,OAAJ,EAAkB,CAACrE,GAAAqF,IAAnB,GACE3B,UAAA,CAAWtE,MAAX,CAAmB,4BAAnB,CACEkG,IAAAC,UAAA,CAAenG,MAAAgG,QAAf,CADF,CAEA,CAAApF,GAAAqF,IAAA,CAAUV,EAAAN,OAHZ,CAMIU,GAAAA,CAAS3F,MAAAQ,KAAA,CAAYR,MAAAQ,KAAAT,OAAZ,CAAiC,CAAjC,CAAT4F,EAAgD3F,MAChDY,IAAAa,GAAJ,EAAckE,EAAAlE,GAAd,GAA4Bb,GAAAa,GAA5B,EACEL,MAAAgF,KAAA,CAAYxF,GAAAa,GAAZ,CAAAsB,QAAA,CAA4B,QAAS,CAACsD,CAAD,CAAI,CACvC1C,QAAA,CAAS3D,MAAT,CAAiB,iBAAjB,CAAoC,CAClCiF,OAAQoB,CAD0B,CAElCJ,IAAKrF,GAAAa,GAAA,CAAO4E,CAAP,CAF6B,CAApC,CADuC,CAAzC,CAWOzG,GAAAA,CAAI,CAAb,KAAK,IAAWC,EAAIG,MAAAuB,WAAAxB,OAApB,CAA8CH,EAA9C,CAAkDC,CAAlD,CAAqDD,EAAA,EAArD,CAA0D,CACxD,IAAI0G,GAAKtG,MAAAuB,WAAA,CAAkB3B,EAAlB,CAAT,CACIgF,KAAO0B,EAAA,CAAG,CAAH,CADX,CAEIT,MAAQS,EAAA,CAAG,CAAH,CAFZ;AAGIxB,SAAWH,KAAA,CAAMC,IAAN,CAAY,CAAA,CAAZ,CACXK,GAAAA,CAASH,QAAAG,OAEb,KAAIgB,IAAiB,EAAX,GAAAhB,EAAA,CAAgB,EAAhB,CAAsBrE,GAAAa,GAAA,CAAOwD,EAAP,CAAtB,EAAwC,EAC9CsB,MAAAA,CAAI,CACN3B,KAAMA,IADA,CAENiB,MAAOA,KAFD,CAGNZ,OAAQA,EAHF,CAINC,MANUJ,QAAAI,MAEJ,CAKNe,IAAKA,GALC,CAUJhB,GAAJ,EAAyB,OAAzB,GAAcA,EAAd,EAAoC,CAACgB,GAArC,GACE3B,UAAA,CAAWtE,MAAX,CAAmB,4BAAnB,CACEkG,IAAAC,UAAA,CAAelB,EAAf,CADF,CAEA,CAAAsB,KAAAN,IAAA,CAAQhB,EAHV,CAKAjF,OAAAY,IAAAyE,WAAA,CAAsBT,IAAtB,CAAA,CAA8B2B,KAC9B5C,SAAA,CAAS3D,MAAT,CAAiB,aAAjB,CAAgCuG,KAAhC,CAxBwD,CA0B1DvG,MAAAuB,WAAAxB,OAAA,CAA2B,CAvDP,CA0DtBC,MAAAY,IAAA4F,cAAA,CAA2B,CAAC,CAACT,WAG7B/F,OAAAW,QAAA,CAAiB,CAAA,CACjBX,OAAAQ,KAAAoF,KAAA,CAAiB5F,MAAAY,IAAjB,CACA+C,SAAA,CAAS3D,MAAT,CAAiB,WAAjB,CAA8BA,MAAAY,IAA9B,CACKmF,YAAL,GAEO/F,MAAAc,SAAL;AAAyD,QAAzD,GAAwBd,MAAAgG,QAAAS,YAAA,EAAxB,CAGEzG,MAAAe,MAHF,CAGiBC,CAAAwD,KAHjB,CACExE,MAAAe,MADF,CACiBC,CAAA0F,OAKjB,CADA1G,MAAAY,IACA,CADa,IACb,CAAAZ,MAAAgG,QAAA,CAAiB,EARnB,CAUAhG,OAAAoF,WAAA,CAAoBpF,MAAAwF,YAApB,CAAyC,EACzCxF,OAAAuB,WAAAxB,OAAA,CAA2B,CA5EU,CA+EvC4G,QAASA,SAAS,CAAC3G,MAAD,CAAS,CACzB,GAAKA,MAAAgG,QAAL,CAAA,CAOA,GAAIhG,MAAA4G,OAAJ,CAAmB,CACjB,GAAuB,QAAvB,GAAI5G,MAAAgG,QAAJ,CAAiC,CAC/BhG,MAAA4G,OAAA,EAAiB,OAAjB,CAAwB5G,MAAAgG,QAAxB,CAAyC,MACzChG,OAAAgG,QAAA,CAAiB,EACjBhG,OAAAe,MAAA,CAAeC,CAAA0F,OACf,OAJ+B,CAMjC/C,QAAA,CAAS3D,MAAT,CAAiB,UAAjB,CAA6BA,MAAA4G,OAA7B,CACA5G,OAAA4G,OAAA,CAAgB,EARC,CAanB,IAAIC,EAAI7G,MAAAQ,KAAAT,OAAR,CACIiG,QAAUhG,MAAAgG,QACThG,OAAAN,OAAL,GACEsG,OADF,CACYA,OAAA,CAAQhG,MAAAO,UAAR,CAAA,EADZ,CAIA;IADA,IAAIuG,QAAUd,OACd,CAAOa,CAAA,EAAP,CAAA,CAEE,GADY7G,MAAAQ,KAAAuG,CAAYF,CAAZE,CACRnC,KAAJ,GAAmBkC,OAAnB,CAEExC,UAAA,CAAWtE,MAAX,CAAmB,sBAAnB,CAFF,KAIE,MAKJ,IAAQ,CAAR,CAAI6G,CAAJ,CACEvC,UAAA,CAAWtE,MAAX,CAAmB,yBAAnB,CAA+CA,MAAAgG,QAA/C,CACA,CAAAhG,MAAA6D,SAAA,EAAmB,OAAnB,CAA0B7D,MAAAgG,QAA1B,CAA2C,MAF7C,KAAA,CAMAhG,MAAAgG,QAAA,CAAiBA,OAEjB,KADIgB,OACJ,CADQhH,MAAAQ,KAAAT,OACR,CAAOiH,OAAA,EAAP,EAAaH,CAAb,CAAA,CAAgB,CACd,IAAIjG,IAAMZ,MAAAY,IAANA,CAAmBZ,MAAAQ,KAAAyG,IAAA,EACvBjH,OAAAgG,QAAA,CAAiBhG,MAAAY,IAAAgE,KACjBjB,SAAA,CAAS3D,MAAT,CAAiB,YAAjB,CAA+BA,MAAAgG,QAA/B,CAGA,KAAKpG,IAAIA,CAAT,GAAcgB,IAAAa,GAAd,EAIIkE,OAAAA,CAAS3F,MAAAQ,KAAA,CAAYR,MAAAQ,KAAAT,OAAZ,CAAiC,CAAjC,CAAT4F,EAAgD3F,MAChDA,OAAAL,IAAA6B,MAAJ;AAAwBZ,GAAAa,GAAxB,GAAmCkE,OAAAlE,GAAnC,EAEEL,MAAAgF,KAAA,CAAYxF,GAAAa,GAAZ,CAAAsB,QAAA,CAA4B,QAAS,CAACsD,CAAD,CAAI,CAEvC1C,QAAA,CAAS3D,MAAT,CAAiB,kBAAjB,CAAqC,CAAEiF,OAAQoB,CAAV,CAAaJ,IAD1CrF,GAAAa,GAAAyF,CAAOb,CAAPa,CAC6B,CAArC,CAFuC,CAAzC,CAbY,CAmBN,CAAV,GAAIL,CAAJ,GAAa7G,MAAAU,WAAb,CAAiC,CAAA,CAAjC,CACAV,OAAAgG,QAAA,CAAiBhG,MAAAwF,YAAjB,CAAsCxF,MAAAoF,WAAtC,CAA0D,EAC1DpF,OAAAuB,WAAAxB,OAAA,CAA2B,CA7B3B,CArCA,CAAA,IACEuE,WAAA,CAAWtE,MAAX,CAAmB,wBAAnB,CACA,CAAAA,MAAA6D,SAAA,EAAmB,WACnB7D,OAAAe,MAAA,CAAeC,CAAAwD,KAJQ,CAuE3B2C,QAASA,YAAY,CAACnH,MAAD,CAAS,CAC5B,IAAIoH,OAASpH,MAAAoH,OAAb,CACIC,SAAWD,MAAAX,YAAA,EADf,CAGIa,OAAS,EAEb,IAAItH,MAAAkB,SAAA,CAAgBkG,MAAhB,CAAJ,CACE,MAAOpH,OAAAkB,SAAA,CAAgBkG,MAAhB,CAET,IAAIpH,MAAAkB,SAAA,CAAgBmG,QAAhB,CAAJ,CACE,MAAOrH,OAAAkB,SAAA,CAAgBmG,QAAhB,CAETD;MAAA,CAASC,QACT,IAAyB,GAAzB,GAAID,MAAAG,OAAA,CAAc,CAAd,CAAJ,CACE,GAAyB,GAAzB,GAAIH,MAAAG,OAAA,CAAc,CAAd,CAAJ,CAA8B,CAC5BH,MAAA,CAASA,MAAAI,MAAA,CAAa,CAAb,CACT,KAAAC,IAAMC,QAAA,CAASN,MAAT,CAAiB,EAAjB,CACNE,OAAA,CAASG,GAAAE,SAAA,CAAa,EAAb,CAHmB,CAA9B,IAKEP,OAEA,CAFSA,MAAAI,MAAA,CAAa,CAAb,CAET,CADAC,GACA,CADMC,QAAA,CAASN,MAAT,CAAiB,EAAjB,CACN,CAAAE,MAAA,CAASG,GAAAE,SAAA,CAAa,EAAb,CAGbP,OAAA,CAASA,MAAAjD,QAAA,CAAe,KAAf,CAAsB,EAAtB,CACT,OAAIyD,MAAA,CAAMH,GAAN,CAAJ,EAAkBH,MAAAb,YAAA,EAAlB,GAA2CW,MAA3C,EACE9C,UAAA,CAAWtE,MAAX,CAAmB,0BAAnB,CACO,CAAA,MAAA,CAAMA,MAAAoH,OAAN,CAAsB,GAF/B,EAKOS,MAAAC,cAAA,CAAqBL,GAArB,CA9BqB,CAiC9BM,QAASA,gBAAgB,CAAC/H,MAAD,CAASE,CAAT,CAAY,CACzB,MAAV,GAAIA,CAAJ,EACEF,MAAAe,MACA,CADeC,CAAAgH,UACf,CAAAhI,MAAAiI,iBAAA,CAA0BjI,MAAA4B,SAF5B;AAGY6B,YAAA,CAAavD,CAAb,CAHZ,GAMEoE,UAAA,CAAWtE,MAAX,CAAmB,kCAAnB,CAEA,CADAA,MAAA6D,SACA,CADkB3D,CAClB,CAAAF,MAAAe,MAAA,CAAeC,CAAAwD,KARjB,CADmC,CAarC+C,QAASA,OAAO,CAACW,KAAD,CAAQtI,CAAR,CAAW,CACzB,IAAIuI,OAAS,EACTvI,EAAJ,CAAQsI,KAAAnI,OAAR,GACEoI,MADF,CACWD,KAAAX,OAAA,CAAa3H,CAAb,CADX,CAGA,OAAOuI,OALkB,CA37B3B3I,GAAAQ,OAAA,CAAaoI,QAAS,CAAC1I,MAAD,CAASC,GAAT,CAAc,CAAE,MAAO,KAAIF,SAAJ,CAAcC,MAAd,CAAsBC,GAAtB,CAAT,CACpCH,IAAAC,UAAA,CAAgBA,SAChBD,IAAAwC,UAAA,CAAgBA,SAChBxC,IAAA6I,aAAA,CAuKAA,QAAsB,CAAC3I,MAAD,CAASC,GAAT,CAAc,CAClC,MAAO,KAAIqC,SAAJ,CAActC,MAAd,CAAsBC,GAAtB,CAD2B,CA5JpCH,IAAAY,kBAAA,CAAwB,KAExB,KAAIN,QAAU,gHAAA,MAAA,CAAA,GAAA,CAMdN;GAAA8I,OAAA,CAAa,mLAAA,MAAA,CAAA,GAAA,CA0DRlH,OAAAC,OAAL,GACED,MAAAC,OADF,CACkBkH,QAAS,CAACC,CAAD,CAAI,CAC3BC,QAASA,EAAE,EAAG,EACdA,CAAAC,UAAA,CAAcF,CAEd,OADWG,KAAIF,CAHY,CAD/B,CASKrH,OAAAgF,KAAL,GACEhF,MAAAgF,KADF,CACgBwC,QAAS,CAACJ,CAAD,CAAI,CACzB,IAAIjC,EAAI,EAAR,CACS3G,CAAT,KAASA,CAAT,GAAc4I,EAAd,CAAqBA,CAAAlD,eAAA,CAAiB1F,CAAjB,CAAJ,EAAyB2G,CAAAX,KAAA,CAAOhG,CAAP,CAC1C,OAAO2G,EAHkB,CAD7B,CA8DA9G,UAAAiJ,UAAA,CAAsB,CACpBrE,IAAKA,QAAS,EAAG,CAAEA,GAAA,CAAI,IAAJ,CAAF,CADG,CAEpBwE,MA0yBFA,QAAe,CAACX,KAAD,CAAQ,CAErB,GAAI,IAAArH,MAAJ,CACE,KAAM,KAAAA,MAAN,CAEF,GAJab,IAITS,OAAJ,CACE,MAAOI,MAAA,CALIb,IAKJ;AACL,sDADK,CAGT,IAAc,IAAd,GAAIkI,KAAJ,CACE,MAAO7D,IAAA,CATIrE,IASJ,CAEY,SAArB,GAAI,MAAOkI,MAAX,GACEA,KADF,CACUA,KAAAP,SAAA,EADV,CAKA,KAFA,IAAI/H,EAAI,CAAR,CACIM,CACJ,CAAA,CAAA,CAAa,CAhBAF,IAkBXE,EAAA,CADAA,CACA,CADIqH,MAAA,CAAOW,KAAP,CAActI,CAAA,EAAd,CAGJ,IAAI,CAACM,CAAL,CACE,KArBSF,KAwBP2B,cAAJ,GAxBW3B,IAyBT4B,SAAA,EACA,CAAU,IAAV,GAAI1B,CAAJ,EA1BSF,IA2BP6B,KAAA,EACA,CA5BO7B,IA4BP8B,OAAA,CAAgB,CAFlB,EA1BS9B,IA8BP8B,OAAA,EANJ,CAUA,QAlCW9B,IAkCHe,MAAR,EACE,KAAKC,CAAAC,MAAL,CAnCSjB,IAoCPe,MAAA,CAAeC,CAAAuD,iBACf,IAAU,GAAV,GAAIrE,CAAJ,CACE,QAEF6H,gBAAA,CAxCO/H,IAwCP,CAAwBE,CAAxB,CACA,SAEF,MAAKc,CAAAuD,iBAAL,CACEwD,eAAA,CA5CO/H,IA4CP,CAAwBE,CAAxB,CACA,SAEF,MAAKc,CAAAwD,KAAL,CACE,GAhDOxE,IAgDHW,QAAJ,EAAsB,CAhDfX,IAgDgBU,WAAvB,CAA0C,CAExC,IADA,IAAIoI;AAASlJ,CAATkJ,CAAa,CACjB,CAAO5I,CAAP,EAAkB,MAAlB,GAAYA,CAAZ,EAA+B,MAA/B,GAAyBA,CAAzB,CAAA,CAEE,CADAA,CACA,CADIqH,MAAA,CAAOW,KAAP,CAActI,CAAA,EAAd,CACJ,GApDGI,IAoDM2B,cAAT,GApDG3B,IAqDD4B,SAAA,EACA,CAAU,IAAV,GAAI1B,CAAJ,EAtDCF,IAuDC6B,KAAA,EACA,CAxDD7B,IAwDC8B,OAAA,CAAgB,CAFlB,EAtDC9B,IA0DC8B,OAAA,EANJ,CApDG9B,KA8DL6D,SAAA,EAAmBqE,KAAAa,UAAA,CAAgBD,MAAhB,CAAwBlJ,CAAxB,CAA4B,CAA5B,CAdqB,CAgBhC,MAAV,GAAIM,CAAJ,EAhEOF,IAgEYW,QAAnB,EAhEOX,IAgE8BU,WAArC,EAA0D,CAhEnDV,IAgEoDN,OAA3D,EAIO+D,YAAA,CAAavD,CAAb,CAGL,EAvEKF,IAoEqBW,QAG1B,EAH4CD,CApEvCV,IAoEuCU,WAG5C,EAFE4D,UAAA,CArEGtE,IAqEH,CAAmB,iCAAnB,CAEF,CAAU,MAAV,GAAIE,CAAJ,CAvEKF,IAwEHe,MADF,CACiBC,CAAAgI,YADjB,CAvEKhJ,IA0EH6D,SAHF,EAGqB3D,CAVvB,GAhEOF,IAiELe,MACA,CADeC,CAAAgH,UACf,CAlEKhI,IAkELiI,iBAAA,CAlEKjI,IAkEqB4B,SAF5B,CAaA,SAEF,MAAKZ,CAAA0F,OAAL,CAEY,MAAV,GAAIxG,CAAJ,CAjFOF,IAkFLe,MADF;AACiBC,CAAAiI,cADjB,CAjFOjJ,IAoFL4G,OAHF,EAGmB1G,CAEnB,SAEF,MAAKc,CAAAiI,cAAL,CACY,GAAV,GAAI/I,CAAJ,CAzFOF,IA0FLe,MADF,CACiBC,CAAAkI,UADjB,EAzFOlJ,IA4FL4G,OACA,EADiB,MACjB,CADuB1G,CACvB,CA7FKF,IA6FLe,MAAA,CAAeC,CAAA0F,OAJjB,CAMA,SAEF,MAAK1F,CAAAgH,UAAL,CAEY,GAAV,GAAI9H,CAAJ,EAnGOF,IAoGLe,MACA,CADeC,CAAAmI,UACf,CArGKnJ,IAqGLoJ,SAAA,CAAkB,EAFpB,EAGW3F,YAAA,CAAavD,CAAb,CAHX,GAKmBmJ,SAnwBlBC,KAAA,CAmwB6BpJ,CAnwB7B,CAmwBM,EAxGAF,IAyGLe,MACA,CADeC,CAAAuI,SACf,CA1GKvJ,IA0GLgG,QAAA,CAAiB9F,CAFZ,EAGU,GAAV,GAAIA,CAAJ,EA3GAF,IA4GLe,MACA,CADeC,CAAAkI,UACf,CA7GKlJ,IA6GLgG,QAAA,CAAiB,EAFZ,EAGU,GAAV,GAAI9F,CAAJ,EA9GAF,IA+GLe,MACA,CADeC,CAAAwI,UACf,CAhHKxJ,IAgHLyJ,aAAA,CAhHKzJ,IAgHiB0J,aAAtB,CAA4C,EAFvC,GAILpF,UAAA,CAlHKtE,IAkHL,CAAmB,gBAAnB,CAOA,CAzHKA,IAoHDiI,iBAKJ,CAL8B,CAK9B,CAzHKjI,IAoH6B4B,SAKlC,GAHE1B,CAGF,CAHUyJ,KAAJ,CAtHD3J,IAqHO4B,SACN;AAtHD5B,IAqHyBiI,iBACxB,CAAA2B,KAAA,CAAoB,GAApB,CAGN,CAHiC1J,CAGjC,EAzHKF,IAwHL6D,SACA,EADmB,MACnB,CADyB3D,CACzB,CAzHKF,IAyHLe,MAAA,CAAeC,CAAAwD,KAXV,CAXP,CAwBA,SAEF,MAAKxD,CAAAmI,UAAL,CACMU,CA9HG7J,IA8HFoJ,SAADS,CAAmB3J,CAAnB2J,aAAA,EAAJ,GAA4CC,KAA5C,EACEnG,QAAA,CA/HK3D,IA+HL,CAAiB,aAAjB,CAGA,CAlIKA,IAgILe,MAEA,CAFeC,CAAA8I,MAEf,CAlIK9J,IAkIL+J,MAAA,CAlIK/J,IAiILoJ,SACA,CADkB,EAHpB,EAKmC,IAA5B,GAnIApJ,IAmIIoJ,SAAJ,CAAsBlJ,CAAtB,EAnIAF,IAoILe,MAEA,CAFeC,CAAAgJ,QAEf,CAtIKhK,IAsILoJ,SAAA,CAtIKpJ,IAqILiK,QACA,CADiB,EAFZ,EAIIJ,CAvIJ7J,IAuIKoJ,SAADS,CAAmB3J,CAAnB2J,aAAA,EAAJ,GAA4CK,OAA5C,EAvIAlK,IAwILe,MAMA,CANeC,CAAAkJ,QAMf,EA9IKlK,IAyIDmK,QAKJ,EA9IKnK,IAyIiBW,QAKtB,GAJE2D,UAAA,CA1IGtE,IA0IH,CACE,6CADF,CAIF,CA9IKA,IA8ILoJ,SAAA,CA9IKpJ,IA6ILmK,QACA,CADiB,EANZ,EAQU,MAAV,GAAIjK,CAAJ,EACLyD,QAAA,CAhJK3D,IAgJL;AAAiB,mBAAjB,CAhJKA,IAgJiCoJ,SAAtC,CAEA,CAlJKpJ,IAiJLoJ,SACA,CADkB,EAClB,CAlJKpJ,IAkJLe,MAAA,CAAeC,CAAAwD,KAHV,GAIId,OAAA,CAAQxD,CAAR,CAET,GArJKF,IAoJLe,MACA,CADeC,CAAAoJ,iBACf,EArJKpK,IAqJLoJ,SAAA,EAAmBlJ,CANd,CAUP,SAEF,MAAKc,CAAAoJ,iBAAL,CACMlK,CAAJ,GA5JOF,IA4JGC,EAAV,GA5JOD,IA6JLe,MACA,CADeC,CAAAmI,UACf,CA9JKnJ,IA8JLC,EAAA,CAAW,EAFb,CA5JOD,KAgKPoJ,SAAA,EAAmBlJ,CACnB,SAEF,MAAKc,CAAAkJ,QAAL,CACY,MAAV,GAAIhK,CAAJ,EApKOF,IAqKLe,MAEA,CAFeC,CAAAwD,KAEf,CADAb,QAAA,CAtKK3D,IAsKL,CAAiB,WAAjB,CAtKKA,IAsKyBmK,QAA9B,CACA,CAvKKnK,IAuKLmK,QAAA,CAAiB,CAAA,CAHnB,GApKOnK,IAyKLmK,QACA,EADkBjK,CAClB,CAAU,GAAV,GAAIA,CAAJ,CA1KKF,IA2KHe,MADF,CACiBC,CAAAqJ,YADjB,CAEW3G,OAAA,CAAQxD,CAAR,CAFX,GA1KKF,IA6KHe,MACA,CADeC,CAAAsJ,eACf,CA9KGtK,IA8KHC,EAAA,CAAWC,CAJb,CANF,CAaA,SAEF,MAAKc,CAAAsJ,eAAL,CAnLStK,IAoLPmK,QAAA,EAAkBjK,CACdA,EAAJ,GArLOF,IAqLGC,EAAV;CArLOD,IAsLLC,EACA,CADW,EACX,CAvLKD,IAuLLe,MAAA,CAAeC,CAAAkJ,QAFjB,CAIA,SAEF,MAAKlJ,CAAAqJ,YAAL,CA3LSrK,IA4LPmK,QAAA,EAAkBjK,CACR,IAAV,GAAIA,CAAJ,CA7LOF,IA8LLe,MADF,CACiBC,CAAAkJ,QADjB,CAEWxG,OAAA,CAAQxD,CAAR,CAFX,GA7LOF,IAgMLe,MACA,CADeC,CAAAuJ,mBACf,CAjMKvK,IAiMLC,EAAA,CAAWC,CAJb,CAMA,SAEF,MAAKc,CAAAuJ,mBAAL,CArMSvK,IAsMPmK,QAAA,EAAkBjK,CACdA,EAAJ,GAvMOF,IAuMGC,EAAV,GAvMOD,IAwMLe,MACA,CADeC,CAAAqJ,YACf,CAzMKrK,IAyMLC,EAAA,CAAW,EAFb,CAIA,SAEF,MAAKe,CAAAgJ,QAAL,CACY,GAAV,GAAI9J,CAAJ,CA9MOF,IA+MLe,MADF,CACiBC,CAAAwJ,eADjB,CA9MOxK,IAiNLiK,QAHF,EAGoB/J,CAEpB,SAEF,MAAKc,CAAAwJ,eAAL,CACY,GAAV,GAAItK,CAAJ,EAtNOF,IAuNLe,MAKA,CALeC,CAAAyJ,cAKf,EA5NKzK,IAwNLiK,QAIA,CAJiBlG,QAAA,CAxNZ/D,IAwNqBL,IAAT,CAxNZK,IAwNiCiK,QAArB,CAIjB,GAFEtG,QAAA,CA1NG3D,IA0NH,CAAiB,WAAjB,CA1NGA,IA0N2BiK,QAA9B,CAEF,CA5NKjK,IA4NLiK,QAAA;AAAiB,EANnB,GAtNOjK,IA8NLiK,QACA,EADkB,GAClB,CADwB/J,CACxB,CA/NKF,IA+NLe,MAAA,CAAeC,CAAAgJ,QATjB,CAWA,SAEF,MAAKhJ,CAAAyJ,cAAL,CACY,MAAV,GAAIvK,CAAJ,EACEoE,UAAA,CArOKtE,IAqOL,CAAmB,mBAAnB,CAIA,CAzOKA,IAwOLiK,QACA,EADkB,IAClB,CADyB/J,CACzB,CAzOKF,IAyOLe,MAAA,CAAeC,CAAAgJ,QALjB,EApOOhK,IA2OLe,MAPF,CAOiBC,CAAAwD,KAEjB,SAEF,MAAKxD,CAAA8I,MAAL,CACY,GAAV,GAAI5J,CAAJ,CAhPOF,IAiPLe,MADF,CACiBC,CAAA0J,aADjB,CAhPO1K,IAmPL+J,MAHF,EAGkB7J,CAElB,SAEF,MAAKc,CAAA0J,aAAL,CACY,GAAV,GAAIxK,CAAJ,CAxPOF,IAyPLe,MADF,CACiBC,CAAA2J,eADjB,EAxPO3K,IA2PL+J,MACA,EADgB,GAChB,CADsB7J,CACtB,CA5PKF,IA4PLe,MAAA,CAAeC,CAAA8I,MAJjB,CAMA,SAEF,MAAK9I,CAAA2J,eAAL,CACY,MAAV,GAAIzK,CAAJ,EAjQOF,IAkQD+J,MAKJ,EAJEpG,QAAA,CAnQG3D,IAmQH,CAAiB,SAAjB,CAnQGA,IAmQyB+J,MAA5B,CAIF,CAFApG,QAAA,CArQK3D,IAqQL,CAAiB,cAAjB,CAEA,CAvQKA,IAsQL+J,MACA,CADe,EACf,CAvQK/J,IAuQLe,MAAA;AAAeC,CAAAwD,KANjB,EAOiB,GAAV,GAAItE,CAAJ,CAxQAF,IAyQL+J,MADK,EACW,GADX,EAxQA/J,IA2QL+J,MACA,EADgB,IAChB,CADuB7J,CACvB,CA5QKF,IA4QLe,MAAA,CAAeC,CAAA8I,MAJV,CAMP,SAEF,MAAK9I,CAAAwI,UAAL,CACY,GAAV,GAAItJ,CAAJ,CAjROF,IAkRLe,MADF,CACiBC,CAAA4J,iBADjB,CAEWnH,YAAA,CAAavD,CAAb,CAAJ,CAnRAF,IAoRLe,MADK,CACUC,CAAA6J,eADV,CAnRA7K,IAsRLyJ,aAHK,EAGkBvJ,CAEzB,SAEF,MAAKc,CAAA6J,eAAL,CACE,GAAI,CA3RG7K,IA2RF0J,aAAL,EAA4BjG,YAAA,CAAavD,CAAb,CAA5B,CACE,QADF,KAEiB,GAAV,GAAIA,CAAJ,CA7RAF,IA8RLe,MADK,CACUC,CAAA4J,iBADV,CA7RA5K,IAgSL0J,aAHK,EAGkBxJ,CAEzB,SAEF,MAAKc,CAAA4J,iBAAL,CACY,MAAV,GAAI1K,CAAJ,EACEyD,QAAA,CAtSK3D,IAsSL,CAAiB,yBAAjB,CAA4C,CAC1C4E,KAvSG5E,IAuSGyJ,aADoC,CAE1CqB,KAxSG9K,IAwSG0J,aAFoC,CAA5C,CAKA,CA3SK1J,IA0SLyJ,aACA,CA3SKzJ,IA0SiB0J,aACtB;AAD4C,EAC5C,CA3SK1J,IA2SLe,MAAA,CAAeC,CAAAwD,KANjB,GArSOxE,IA6SL0J,aACA,EADuB,GACvB,CAD6BxJ,CAC7B,CA9SKF,IA8SLe,MAAA,CAAeC,CAAA6J,eATjB,CAWA,SAEF,MAAK7J,CAAAuI,SAAL,CACE,GAAYwB,QA98BXzB,KAAA,CA88BqBpJ,CA98BrB,CA88BD,CAnTOF,IAoTLgG,QAAA,EAAkB9F,CADpB,KAEO,CArTAF,IA5RRN,OAAL,GA4RaM,IA5ROgG,QAApB,CA4RahG,IA5RwBgG,QAAA,CA4RxBhG,IA5RuCO,UAAf,CAAA,EAArC,CACIoF,OAAAA,CA2RS3F,IA3RAQ,KAAA,CA2RAR,IA3RYQ,KAAAT,OAAZ,CAAiC,CAAjC,CAAT4F,EA2RS3F,IA1Rb,KAAIY,IA0RSZ,IA1RHY,IAANA,CAAmB,CAAEgE,KA0RZ5E,IA1RkBgG,QAAR,CAAwBX,WAAY,EAApC,CA0RVrF,KAvRTL,IAAA6B,MAAJ,GACEZ,GAAAa,GADF,CACWkE,MAAAlE,GADX,CAuRazB,KApRbuB,WAAAxB,OAAA,CAA2B,CAC3B4D,SAAA,CAmRa3D,IAnRb,CAAiB,gBAAjB,CAAmCY,GAAnC,CA0kBkB,OAAV,GAAIV,CAAJ,CACE4F,OAAA,CAxTG9F,IAwTH,CADF,CAEiB,GAAV,GAAIE,CAAJ,CAzTFF,IA0THe,MADK,CACUC,CAAAgK,eADV,EAGAvH,YAAA,CAAavD,CAAb,CAGL,EAFEoE,UAAA,CA7TCtE,IA6TD,CAAmB,+BAAnB,CAEF;AA/TGA,IA+THe,MAAA,CAAeC,CAAAiK,OANV,CAJF,CAaP,QAEF,MAAKjK,CAAAgK,eAAL,CACY,MAAV,GAAI9K,CAAJ,EACE4F,OAAA,CAtUK9F,IAsUL,CAAgB,CAAA,CAAhB,CACA,CAAA2G,QAAA,CAvUK3G,IAuUL,CAFF,GAIEsE,UAAA,CAzUKtE,IAyUL,CAAmB,mDAAnB,CACA,CA1UKA,IA0ULe,MAAA,CAAeC,CAAAiK,OALjB,CAOA,SAEF,MAAKjK,CAAAiK,OAAL,CAEE,GAAIxH,YAAA,CAAavD,CAAb,CAAJ,CACE,QADF,KAEiB,MAAV,GAAIA,CAAJ,CACL4F,OAAA,CAnVK9F,IAmVL,CADK,CAEU,GAAV,GAAIE,CAAJ,CApVAF,IAqVLe,MADK,CACUC,CAAAgK,eADV,CAEY3B,SAj/BlBC,KAAA,CAi/B6BpJ,CAj/B7B,CAi/BM,EAtVAF,IAuVLoF,WAEA,CAFoBlF,CAEpB,CAzVKF,IAwVLwF,YACA,CADqB,EACrB,CAzVKxF,IAyVLe,MAAA,CAAeC,CAAAkK,YAHV,EAKL5G,UAAA,CA3VKtE,IA2VL,CAAmB,wBAAnB,CAEF,SAEF,MAAKgB,CAAAkK,YAAL,CACY,MAAV,GAAIhL,CAAJ,CAhWOF,IAiWLe,MADF,CACiBC,CAAAmK,aADjB,CAEiB,MAAV;AAAIjL,CAAJ,EACLoE,UAAA,CAnWKtE,IAmWL,CAAmB,yBAAnB,CAGA,CAtWKA,IAoWLwF,YAEA,CAtWKxF,IAoWgBoF,WAErB,CADAD,MAAA,CArWKnF,IAqWL,CACA,CAAA8F,OAAA,CAtWK9F,IAsWL,CAJK,EAKIyD,YAAA,CAAavD,CAAb,CAAJ,CAvWAF,IAwWLe,MADK,CACUC,CAAAoK,sBADV,CAEYL,QApgClBzB,KAAA,CAogC4BpJ,CApgC5B,CAogCM,CAzWAF,IA0WLoF,WADK,EACgBlF,CADhB,CAGLoE,UAAA,CA5WKtE,IA4WL,CAAmB,wBAAnB,CAEF,SAEF,MAAKgB,CAAAoK,sBAAL,CACE,GAAU,MAAV,GAAIlL,CAAJ,CAjXOF,IAkXLe,MAAA,CAAeC,CAAAmK,aADjB,KAEO,IAAI1H,YAAA,CAAavD,CAAb,CAAJ,CACL,QADK,KAGLoE,WAAA,CAtXKtE,IAsXL,CAAmB,yBAAnB,CAQA,CA9XKA,IAwXLwF,YAMA,CA9XKxF,IAuXLY,IAAAyE,WAAA,CAvXKrF,IAuXiBoF,WAAtB,CAOA,CAP2C,EAO3C,CALAzB,QAAA,CAzXK3D,IAyXL,CAAiB,aAAjB,CAAgC,CAC9B4E,KA1XG5E,IA0XGoF,WADwB;AAE9BS,MAAO,EAFuB,CAAhC,CAKA,CA9XK7F,IA6XLoF,WACA,CADoB,EACpB,CAAU,MAAV,GAAIlF,CAAJ,CACE4F,OAAA,CA/XG9F,IA+XH,CADF,CAEmBqJ,SA3hCpBC,KAAA,CA2hC+BpJ,CA3hC/B,CA2hCQ,EAhYFF,IAiYHoF,WACA,CADoBlF,CACpB,CAlYGF,IAkYHe,MAAA,CAAeC,CAAAkK,YAFV,GAIL5G,UAAA,CApYGtE,IAoYH,CAAmB,wBAAnB,CACA,CArYGA,IAqYHe,MAAA,CAAeC,CAAAiK,OALV,CAQT,SAEF,MAAKjK,CAAAmK,aAAL,CACE,GAAI1H,YAAA,CAAavD,CAAb,CAAJ,CACE,QADF,KAEWwD,QAAA,CAAQxD,CAAR,CAAJ,EA7YAF,IA8YLC,EACA,CADWC,CACX,CA/YKF,IA+YLe,MAAA,CAAeC,CAAAqK,oBAFV,GAIL/G,UAAA,CAjZKtE,IAiZL,CAAmB,0BAAnB,CAEA,CAnZKA,IAkZLe,MACA,CADeC,CAAAsK,sBACf,CAnZKtL,IAmZLwF,YAAA,CAAqBtF,CANhB,CAQP,SAEF,MAAKc,CAAAqK,oBAAL,CACE,GAAInL,CAAJ,GAxZOF,IAwZGC,EAAV,CAAoB,CACR,MAAV,GAAIC,CAAJ,CAzZKF,IA0ZHe,MADF,CACiBC,CAAAuK,sBADjB,CAzZKvL,IA4ZHwF,YAHF;AAGwBtF,CAExB,SANkB,CAQpBiF,MAAA,CAhaOnF,IAgaP,CAhaOA,KAiaPC,EAAA,CAAW,EAjaJD,KAkaPe,MAAA,CAAeC,CAAAwK,oBACf,SAEF,MAAKxK,CAAAwK,oBAAL,CACM/H,YAAA,CAAavD,CAAb,CAAJ,CAtaOF,IAuaLe,MADF,CACiBC,CAAAiK,OADjB,CAEiB,MAAV,GAAI/K,CAAJ,CACL4F,OAAA,CAzaK9F,IAyaL,CADK,CAEU,GAAV,GAAIE,CAAJ,CA1aAF,IA2aLe,MADK,CACUC,CAAAgK,eADV,CAEY3B,SAvkClBC,KAAA,CAukC6BpJ,CAvkC7B,CAukCM,EACLoE,UAAA,CA7aKtE,IA6aL,CAAmB,kCAAnB,CAGA,CAhbKA,IA8aLoF,WAEA,CAFoBlF,CAEpB,CAhbKF,IA+aLwF,YACA,CADqB,EACrB,CAhbKxF,IAgbLe,MAAA,CAAeC,CAAAkK,YAJV,EAML5G,UAAA,CAlbKtE,IAkbL,CAAmB,wBAAnB,CAEF,SAEF,MAAKgB,CAAAsK,sBAAL,CACE,GAtlCO,MAslCP,GAAiBpL,CAAjB,EAtlCc,CAAAuD,YAAA,CAslCGvD,CAtlCH,CAslCd,CAAqB,CACT,MAAV,GAAIA,CAAJ,CAxbKF,IAybHe,MADF,CACiBC,CAAAyK,sBADjB,CAxbKzL,IA2bHwF,YAHF;AAGwBtF,CAExB,SANmB,CAQrBiF,MAAA,CA/bOnF,IA+bP,CACU,OAAV,GAAIE,CAAJ,CACE4F,OAAA,CAjcK9F,IAicL,CADF,CAhcOA,IAmcLe,MAHF,CAGiBC,CAAAiK,OAEjB,SAEF,MAAKjK,CAAAkI,UAAL,CACE,GAxcOlJ,IAwcFgG,QAAL,CAaiB,MAAV,GAAI9F,CAAJ,CACLyG,QAAA,CAtdK3G,IAsdL,CADK,CAEY+K,QAlnClBzB,KAAA,CAknC4BpJ,CAlnC5B,CAknCM,CAvdAF,IAwdLgG,QADK,EACa9F,CADb,CAvdAF,IAydI4G,OAAJ,EAzdA5G,IA0dL4G,OAEA,EAFiB,OAEjB,CA5dK5G,IA0dmBgG,QAExB,CA5dKhG,IA2dLgG,QACA,CADiB,EACjB,CA5dKhG,IA4dLe,MAAA,CAAeC,CAAA0F,OAHV,GAKAjD,YAAA,CAAavD,CAAb,CAGL,EAFEoE,UAAA,CA/dGtE,IA+dH,CAAmB,gCAAnB,CAEF,CAjeKA,IAieLe,MAAA,CAAeC,CAAA0K,oBARV,CAjBP,KACE,IAAIjI,YAAA,CAAavD,CAAb,CAAJ,CACE,QADF,KAEoBmJ,UAtmCrBC,KAAA,CAsmCgCpJ,CAtmChC,CAsmCQ,CA3cFF,IAmdHgG,QARK,CAQY9F,CARZ,CA3cFF,IA4cC4G,OAAJ,EA5cG5G,IA6cD4G,OACA,EADiB,OACjB,CADwB1G,CACxB,CA9cCF,IA8cDe,MAAA,CAAeC,CAAA0F,OAFjB,EAIEpC,UAAA,CAhdCtE,IAgdD,CAAmB,iCAAnB,CAmBN;QAEF,MAAKgB,CAAA0K,oBAAL,CACE,GAAIjI,YAAA,CAAavD,CAAb,CAAJ,CACE,QAEQ,OAAV,GAAIA,CAAJ,CACEyG,QAAA,CA1eK3G,IA0eL,CADF,CAGEsE,UAAA,CA5eKtE,IA4eL,CAAmB,mCAAnB,CAEF,SAEF,MAAKgB,CAAAgI,YAAL,CACA,KAAKhI,CAAAuK,sBAAL,CACA,KAAKvK,CAAAyK,sBAAL,CAGE,OArfOzL,IAqfCe,MAAR,EACE,KAAKC,CAAAgI,YAAL,CACE,IAAA2C,YAAc3K,CAAAwD,KACd,KAAAoH,OAAS,UACT,MAEF,MAAK5K,CAAAuK,sBAAL,CACEI,WAAA,CAAc3K,CAAAqK,oBACdO,OAAA,CAAS,aACT,MAEF,MAAK5K,CAAAyK,sBAAL,CACEE,WACA,CADc3K,CAAAsK,sBACd,CAAAM,MAAA,CAAS,aAbb,CAiBU,GAAV,GAAI1L,CAAJ;CAtgBOF,IAugBL,CAAO4L,MAAP,CAEA,EAFkBzE,WAAA,CAvgBbnH,IAugBa,CAElB,CAzgBKA,IAwgBLoH,OACA,CADgB,EAChB,CAzgBKpH,IAygBLe,MAAA,CAAe4K,WAHjB,EAjqCCrC,CA2pBMtJ,IA0gBYoH,OAAArH,OAAA8L,CAAuBC,UAAvBD,CAAoCE,WArqCtDzC,MAAA,CAqqCmEpJ,CArqCnE,CAqqCM,CA1gBAF,IA2gBLoH,OADK,EACYlH,CADZ,EAGLoE,UAAA,CA7gBKtE,IA6gBL,CAAmB,kCAAnB,CAGA,CAhhBKA,IA8gBL,CAAO4L,MAAP,CAEA,EAFkB,MAElB,CAhhBK5L,IA8gBmBoH,OAExB,CAFwClH,CAExC,CAhhBKF,IA+gBLoH,OACA,CADgB,EAChB,CAhhBKpH,IAghBLe,MAAA,CAAe4K,WANV,CASP,SAEF,SACE,KAAUvH,MAAJ,CAthBCpE,IAshBD,CAAkB,iBAAlB,CAthBCA,IAshBqCe,MAAtC,CAAN,CApfJ,CAlBW,CA0gBb,GA1hBaf,IA0hBT4B,SAAJ,EA1hBa5B,IA0hBUG,oBAAvB,CAAmD,CA53C/C6L,KAAAA,CAAaC,IAAAC,IAAA,CAAS1M,GAAAY,kBAAT,CAAgC,EAAhC,CAERR,EAAAA,CADLuM,CACKvM,CADO,CAChB,KAAgBC,WAAhB,CAAoBC,OAAAC,OAApB,CAAoCH,CAApC,CAAwCC,WAAxC,CAA2CD,CAAA,EAA3C,CAAgD,CAC1CwM,MAAAA,CA+1BOpM,IA/1BD,CAAOF,OAAA,CAAQF,CAAR,CAAP,CAAAG,OACV;GAAIqM,MAAJ,CAAUJ,KAAV,CAKE,OAAQlM,OAAA,CAAQF,CAAR,CAAR,EACE,KAAK,UAAL,CACEkE,SAAA,CAu1BK9D,IAv1BL,CACA,MAEF,MAAK,OAAL,CACE2D,QAAA,CAm1BK3D,IAn1BL,CAAiB,SAAjB,CAm1BKA,IAn1BuB+J,MAA5B,CAm1BK/J,KAl1BL+J,MAAA,CAAe,EACf,MAEF,MAAK,QAAL,CACEpG,QAAA,CA80BK3D,IA90BL,CAAiB,UAAjB,CA80BKA,IA90BwB4G,OAA7B,CA80BK5G,KA70BL4G,OAAA,CAAgB,EAChB,MAEF,SACE/F,KAAA,CAy0BKb,IAz0BL,CAAc,8BAAd,CAA+CF,OAAA,CAAQF,CAAR,CAA/C,CAhBJ,CAmBFuM,CAAA,CAAYF,IAAAC,IAAA,CAASC,CAAT,CAAoBC,MAApB,CA1BkC,CAg2BnCpM,IAl0BbG,oBAAA,CADQX,GAAAY,kBACR,CADgC+L,CAChC,CAk0BanM,IAl0BoB4B,SA41CkB,CAGnD,MA7hBa5B,KADQ,CA5yBD,CAGpBqM,OAAQA,QAAS,EAAG,CAAE,IAAAxL,MAAA,CAAa,IAAM,OAAO,KAA5B,CAHA,CAIpBkG,MAAOA,QAAS,EAAG,CAAE,MAAO,KAAA8B,MAAA,CAAW,IAAX,CAAT,CAJC,CAKpByD,MAAOA,QAAS,EAAG,CAhBnBxI,SAAA,CAgBkC9D,IAhBlC,CACqB,GAArB;AAekCA,IAf9B+J,MAAJ,GACEpG,QAAA,CAcgC3D,IAdhC,CAAiB,SAAjB,CAcgCA,IAdJ+J,MAA5B,CACA,CAagC/J,IAbhC+J,MAAA,CAAe,EAFjB,CAIsB,GAAtB,GAWkC/J,IAX9B4G,OAAJ,GACEjD,QAAA,CAUgC3D,IAVhC,CAAiB,UAAjB,CAUgCA,IAVH4G,OAA7B,CACA,CASgC5G,IAThC4G,OAAA,CAAgB,EAFlB,CAWmB,CALC,CAStB,IAAI,CACF,IAAA3E,OAAS7C,OAAA,CAAQ,6CAAR,CAAA6C,OADP,CAEF,MAAOsK,EAAP,CAAW,CACXtK,MAAA,CAASA,QAAS,EAAG,EADV,CAIb,IAAIa,YAActD,GAAA8I,OAAAkE,OAAA,CAAkB,QAAS,CAACxJ,EAAD,CAAK,CAChD,MAAc,OAAd,GAAOA,EAAP,EAAgC,KAAhC,GAAyBA,EADuB,CAAhC,CAsDlBhB,UAAA0G,UAAA,CAAsBtH,MAAAC,OAAA,CAAcY,MAAAyG,UAAd,CAAgC,CACpD+D,YAAa,CACX5G,MAAO7D,SADI,CADuC,CAAhC,CAMtBA,UAAA0G,UAAAG,MAAA,CAA4B6D,QAAS,CAAC3K,IAAD,CAAO,CACpB,UAAtB,GAAI,MAAOxC,OAAX,EAC6B,UAD7B,GACE,MAAOA,OAAAoN,SADT;AAEEpN,MAAAoN,SAAA,CAAgB5K,IAAhB,CAFF,GAGO,IAAAc,SAIL,GAFE,IAAAA,SAEF,CAFkB,KADPzD,OAAA,CAAQ,uDAAR,CAAAwN,cACO,EAAO,MAAP,CAElB,EAAA7K,IAAA,CAAO,IAAAc,SAAAgG,MAAA,CAAoB9G,IAApB,CAPT,CAUA,KAAAI,QAAA0G,MAAA,CAAmB9G,IAAA4F,SAAA,EAAnB,CACA,KAAAlF,KAAA,CAAU,MAAV,CAAkBV,IAAlB,CACA,OAAO,CAAA,CAbmC,CAgB5CC,UAAA0G,UAAArE,IAAA,CAA0BwI,QAAS,CAAC3E,KAAD,CAAQ,CACrCA,KAAJ,EAAaA,KAAAnI,OAAb,EACE,IAAA8I,MAAA,CAAWX,KAAX,CAEF,KAAA/F,QAAAkC,IAAA,EACA,OAAO,CAAA,CALkC,CAQ3CrC,UAAA0G,UAAApF,GAAA,CAAyBwJ,QAAS,CAAC9J,EAAD,CAAK+J,OAAL,CAAc,CAC9C,IAAIzK,GAAK,IACJA,GAAAH,QAAA,CAAW,IAAX,CAAkBa,EAAlB,CAAL,EAA2D,EAA3D,GAA8BF,WAAAiC,QAAA,CAAoB/B,EAApB,CAA9B,GACEV,EAAAH,QAAA,CAAW,IAAX,CAAkBa,EAAlB,CADF,CAC0B,QAAS,EAAG,CAClC,IAAIgK;AAA4B,CAArB,GAAAC,SAAAlN,OAAA,CAAyB,CAACkN,SAAA,CAAU,CAAV,CAAD,CAAzB,CAA0CtD,KAAAzH,MAAA,CAAY,IAAZ,CAAkB+K,SAAlB,CACrDD,KAAAE,OAAA,CAAY,CAAZ,CAAe,CAAf,CAAkBlK,EAAlB,CACAV,GAAAG,KAAAP,MAAA,CAAcI,EAAd,CAAkB0K,IAAlB,CAHkC,CADtC,CAQA,OAAO/K,OAAAyG,UAAApF,GAAAmB,KAAA,CAAyBnC,EAAzB,CAA6BU,EAA7B,CAAiC+J,OAAjC,CAVuC,CAehD,KAAIjD,MAAQ,SAAZ,CACII,QAAU,SADd,CAEIzE,cAAgB,sCAFpB,CAGIC,gBAAkB,+BAHtB,CAIIhE,OAAS,CAAEyL,IAAK1H,aAAP,CAAsBjE,MAAOkE,eAA7B,CAJb,CAYI2D,UAAY,2JAZhB;AAcI0B,SAAW,+LAdf,CAgBIgB,YAAc,4JAhBlB,CAiBID,WAAa,gMAjBjB;AAuCI9K,EAAI,CACRxB,IAAA4N,MAAA,CAAY,CACVnM,MAAOD,CAAA,EADG,CAEVuD,iBAAkBvD,CAAA,EAFR,CAGVwD,KAAMxD,CAAA,EAHI,CAIVgI,YAAahI,CAAA,EAJH,CAKVgH,UAAWhH,CAAA,EALD,CAMVmI,UAAWnI,CAAA,EAND,CAOVoJ,iBAAkBpJ,CAAA,EAPR,CAQVkJ,QAASlJ,CAAA,EARC,CASVsJ,eAAgBtJ,CAAA,EATN,CAUVqJ,YAAarJ,CAAA,EAVH,CAWVuJ,mBAAoBvJ,CAAA,EAXV,CAYVqM,iBAAkBrM,CAAA,EAZR,CAaVgJ,QAAShJ,CAAA,EAbC,CAcVwJ,eAAgBxJ,CAAA,EAdN,CAeVyJ,cAAezJ,CAAA,EAfL,CAgBV8I,MAAO9I,CAAA,EAhBG,CAiBV0J,aAAc1J,CAAA,EAjBJ,CAkBV2J,eAAgB3J,CAAA,EAlBN,CAmBVwI,UAAWxI,CAAA,EAnBD,CAoBV6J,eAAgB7J,CAAA,EApBN,CAqBV4J,iBAAkB5J,CAAA,EArBR,CAsBVuI,SAAUvI,CAAA,EAtBA,CAuBVgK,eAAgBhK,CAAA,EAvBN,CAwBViK,OAAQjK,CAAA,EAxBE,CAyBVkK,YAAalK,CAAA,EAzBH,CA0BVoK,sBAAuBpK,CAAA,EA1Bb,CA2BVmK,aAAcnK,CAAA,EA3BJ,CA4BVqK,oBAAqBrK,CAAA,EA5BX,CA6BVwK,oBAAqBxK,CAAA,EA7BX;AA8BVsK,sBAAuBtK,CAAA,EA9Bb,CA+BVuK,sBAAuBvK,CAAA,EA/Bb,CAgCVyK,sBAAuBzK,CAAA,EAhCb,CAiCVkI,UAAWlI,CAAA,EAjCD,CAkCV0K,oBAAqB1K,CAAA,EAlCX,CAmCV0F,OAAQ1F,CAAA,EAnCE,CAoCViI,cAAejI,CAAA,EApCL,CAuCZxB,IAAA8B,aAAA,CAAmB,CACjB,IAAO,MADU,CAEjB,GAAM,MAFW,CAGjB,GAAM,MAHW,CAIjB,KAAQ,GAJS,CAKjB,KAAQ,GALS,CAQnB9B,IAAA0B,SAAA,CAAe,CACb,IAAO,MADM,CAEb,GAAM,MAFO,CAGb,GAAM,MAHO,CAIb,KAAQ,GAJK,CAKb,KAAQ,GALK,CAMb,MAAS,GANI,CAOb,OAAU,GAPG,CAQb,MAAS,GARI,CASb,OAAU,GATG,CAUb,MAAS,GAVI,CAWb,OAAU,GAXG,CAYb,KAAQ,GAZK,CAab,OAAU,GAbG,CAcb,IAAO,GAdM,CAeb,OAAU,GAfG,CAgBb,MAAS,GAhBI,CAiBb,OAAU,GAjBG,CAkBb,KAAQ,GAlBK,CAmBb,OAAU,GAnBG,CAoBb,MAAS,GApBI,CAqBb,OAAU,GArBG,CAsBb,KAAQ,GAtBK,CAuBb,OAAU,GAvBG,CAwBb,OAAU,GAxBG,CAyBb,MAAS,GAzBI,CA0Bb,OAAU,GA1BG,CA2Bb,OAAU,GA3BG;AA4Bb,OAAU,GA5BG,CA6Bb,KAAQ,GA7BK,CA8Bb,MAAS,GA9BI,CA+Bb,OAAU,GA/BG,CAgCb,MAAS,GAhCI,CAiCb,OAAU,GAjCG,CAkCb,KAAQ,GAlCK,CAmCb,OAAU,GAnCG,CAoCb,OAAU,GApCG,CAqCb,MAAS,GArCI,CAsCb,MAAS,GAtCI,CAuCb,OAAU,GAvCG,CAwCb,MAAS,GAxCI,CAyCb,OAAU,GAzCG,CA0Cb,KAAQ,GA1CK,CA2Cb,OAAU,GA3CG,CA4Cb,OAAU,GA5CG,CA6Cb,MAAS,GA7CI,CA8Cb,OAAU,GA9CG,CA+Cb,IAAO,GA/CM,CAgDb,KAAQ,GAhDK,CAiDb,OAAU,GAjDG,CAkDb,MAAS,GAlDI,CAmDb,OAAU,GAnDG,CAoDb,KAAQ,GApDK,CAqDb,OAAU,GArDG,CAsDb,OAAU,GAtDG,CAuDb,MAAS,GAvDI,CAwDb,OAAU,GAxDG,CAyDb,OAAU,GAzDG,CA0Db,OAAU,GA1DG,CA2Db,KAAQ,GA3DK,CA4Db,MAAS,GA5DI,CA6Db,MAAS,GA7DI,CA8Db,OAAU,GA9DG,CA+Db,MAAS,GA/DI,CAgEb,OAAU,GAhEG,CAiEb,KAAQ,GAjEK,CAkEb,OAAU,GAlEG,CAmEb,KAAQ,GAnEK,CAoEb,KAAQ,GApEK,CAqEb,IAAO,GArEM,CAsEb,KAAQ,GAtEK,CAuEb,MAAS,GAvEI,CAwEb,KAAQ,GAxEK,CAyEb,MAAS,GAzEI,CA0Eb,OAAU,GA1EG,CA2Eb,IAAO,GA3EM,CA4Eb,OAAU,GA5EG,CA6Eb,KAAQ,GA7EK;AA8Eb,IAAO,GA9EM,CA+Eb,KAAQ,GA/EK,CAgFb,MAAS,GAhFI,CAiFb,IAAO,GAjFM,CAkFb,IAAO,GAlFM,CAmFb,KAAQ,GAnFK,CAoFb,IAAO,GApFM,CAqFb,OAAU,GArFG,CAsFb,KAAQ,GAtFK,CAuFb,KAAQ,GAvFK,CAwFb,KAAQ,GAxFK,CAyFb,MAAS,GAzFI,CA0Fb,MAAS,GA1FI,CA2Fb,KAAQ,GA3FK,CA4Fb,OAAU,GA5FG,CA6Fb,MAAS,GA7FI,CA8Fb,KAAQ,GA9FK,CA+Fb,MAAS,GA/FI,CAgGb,OAAU,GAhGG,CAiGb,OAAU,GAjGG,CAkGb,OAAU,GAlGG,CAmGb,OAAU,GAnGG,CAoGb,MAAS,GApGI,CAqGb,OAAU,GArGG,CAsGb,MAAS,GAtGI,CAuGb,MAAS,GAvGI,CAwGb,OAAU,GAxGG,CAyGb,OAAU,GAzGG,CA0Gb,KAAQ,GA1GK,CA2Gb,KAAQ,GA3GK,CA4Gb,KAAQ,GA5GK,CA6Gb,MAAS,GA7GI,CA8Gb,MAAS,GA9GI,CA+Gb,KAAQ,GA/GK,CAgHb,MAAS,GAhHI,CAiHb,MAAS,GAjHI,CAkHb,QAAW,GAlHE,CAmHb,KAAQ,GAnHK,CAoHb,IAAO,GApHM,CAqHb,MAAS,GArHI,CAsHb,KAAQ,GAtHK,CAuHb,MAAS,GAvHI,CAwHb,OAAU,GAxHG,CAyHb,GAAM,GAzHO,CA0Hb,GAAM,GA1HO,CA2Hb,GAAM,GA3HO,CA4Hb,QAAW,GA5HE,CA6Hb,GAAM,GA7HO,CA8Hb,IAAO,GA9HM,CA+Hb,MAAS,GA/HI,CAgIb,IAAO,GAhIM,CAiIb,QAAW,GAjIE,CAkIb,IAAO,GAlIM;AAmIb,IAAO,GAnIM,CAoIb,IAAO,GApIM,CAqIb,MAAS,GArII,CAsIb,MAAS,GAtII,CAuIb,KAAQ,GAvIK,CAwIb,MAAS,GAxII,CAyIb,MAAS,GAzII,CA0Ib,QAAW,GA1IE,CA2Ib,KAAQ,GA3IK,CA4Ib,IAAO,GA5IM,CA6Ib,MAAS,GA7II,CA8Ib,KAAQ,GA9IK,CA+Ib,MAAS,GA/II,CAgJb,OAAU,GAhJG,CAiJb,GAAM,GAjJO,CAkJb,GAAM,GAlJO,CAmJb,GAAM,GAnJO,CAoJb,QAAW,GApJE,CAqJb,GAAM,GArJO,CAsJb,IAAO,GAtJM,CAuJb,OAAU,GAvJG,CAwJb,MAAS,GAxJI,CAyJb,IAAO,GAzJM,CA0Jb,QAAW,GA1JE,CA2Jb,IAAO,GA3JM,CA4Jb,IAAO,GA5JM,CA6Jb,IAAO,GA7JM,CA8Jb,MAAS,GA9JI,CA+Jb,SAAY,GA/JC,CAgKb,MAAS,GAhKI,CAiKb,IAAO,GAjKM,CAkKb,KAAQ,IAlKK,CAmKb,KAAQ,IAnKK,CAoKb,OAAU,IApKG,CAqKb,KAAQ,IArKK,CAsKb,IAAO,IAtKM,CAuKb,IAAO,IAvKM,CAwKb,IAAO,IAxKM,CAyKb,MAAS,IAzKI,CA0Kb,MAAS,IA1KI,CA2Kb,MAAS,IA3KI,CA4Kb,MAAS,IA5KI,CA6Kb,MAAS,IA7KI,CA8Kb,MAAS,IA9KI,CA+Kb,MAAS,IA/KI,CAgLb,MAAS,IAhLI,CAiLb,OAAU,IAjLG,CAkLb,OAAU,IAlLG,CAmLb,KAAQ,IAnLK,CAoLb,OAAU,IApLG,CAqLb,OAAU,IArLG;AAsLb,MAAS,IAtLI,CAuLb,MAAS,IAvLI,CAwLb,OAAU,IAxLG,CAyLb,OAAU,IAzLG,CA0Lb,MAAS,IA1LI,CA2Lb,MAAS,IA3LI,CA4Lb,KAAQ,IA5LK,CA6Lb,MAAS,IA7LI,CA8Lb,OAAU,IA9LG,CA+Lb,KAAQ,IA/LK,CAgMb,MAAS,IAhMI,CAiMb,QAAW,IAjME,CAkMb,KAAQ,IAlMK,CAmMb,KAAQ,IAnMK,CAoMb,KAAQ,IApMK,CAqMb,KAAQ,IArMK,CAsMb,KAAQ,IAtMK,CAuMb,MAAS,IAvMI,CAwMb,KAAQ,IAxMK,CAyMb,KAAQ,IAzMK,CA0Mb,KAAQ,IA1MK,CA2Mb,KAAQ,IA3MK,CA4Mb,KAAQ,IA5MK,CA6Mb,OAAU,IA7MG,CA8Mb,KAAQ,IA9MK,CA+Mb,MAAS,IA/MI,CAgNb,MAAS,IAhNI,CAiNb,MAAS,IAjNI,CAkNb,KAAQ,IAlNK,CAmNb,MAAS,IAnNI,CAoNb,GAAM,IApNO,CAqNb,KAAQ,IArNK,CAsNb,IAAO,IAtNM,CAuNb,MAAS,IAvNI,CAwNb,OAAU,IAxNG,CAyNb,MAAS,IAzNI,CA0Nb,KAAQ,IA1NK,CA2Nb,MAAS,IA3NI,CA4Nb,IAAO,IA5NM,CA6Nb,IAAO,IA7NM,CA8Nb,GAAM,IA9NO,CA+Nb,IAAO,IA/NM,CAgOb,IAAO,IAhOM,CAiOb,MAAO,IAjOM,CAkOb,OAAU,IAlOG,CAmOb,IAAO,IAnOM,CAoOb,KAAQ,IApOK,CAqOb,MAAS,IArOI;AAsOb,GAAM,IAtOO,CAuOb,MAAS,IAvOI,CAwOb,GAAM,IAxOO,CAyOb,GAAM,IAzOO,CA0Ob,IAAO,IA1OM,CA2Ob,IAAO,IA3OM,CA4Ob,KAAQ,IA5OK,CA6Ob,KAAQ,IA7OK,CA8Ob,KAAQ,IA9OK,CA+Ob,MAAS,IA/OI,CAgPb,OAAU,IAhPG,CAiPb,KAAQ,IAjPK,CAkPb,KAAQ,IAlPK,CAmPb,MAAS,IAnPI,CAoPb,MAAS,IApPI,CAqPb,OAAU,IArPG,CAsPb,OAAU,IAtPG,CAuPb,KAAQ,IAvPK,CAwPb,KAAQ,IAxPK,CAyPb,IAAO,IAzPM,CA0Pb,OAAU,IA1PG,CA2Pb,MAAS,IA3PI,CA4Pb,OAAU,IA5PG,CA6Pb,MAAS,IA7PI,CAgQfE,OAAAgF,KAAA,CAAY5G,GAAA0B,SAAZ,CAAA6B,QAAA,CAAkC,QAAS,CAACuK,GAAD,CAAM,CAC/C,IAAIC,EAAI/N,GAAA0B,SAAA,CAAaoM,GAAb,CACJtG,EAAAA,CAAiB,QAAb,GAAA,MAAOuG,EAAP,CAAwB1F,MAAA2F,aAAA,CAAoBD,CAApB,CAAxB,CAAiDA,CACzD/N,IAAA0B,SAAA,CAAaoM,GAAb,CAAA,CAAoBtG,CAH2B,CAAjD,CAMA,KAAKA,IAAIA,CAAT,GAAcxH,IAAA4N,MAAd,CACE5N,GAAA4N,MAAA,CAAU5N,GAAA4N,MAAA,CAAUpG,CAAV,CAAV,CAAA,CAA0BA,CAI5BhG,EAAA,CAAIxB,GAAA4N,MA23BCvF,OAAAC,cAAL,EACG,QAAS,EAAG,CACX,IAAI2F;AAAqB5F,MAAA2F,aAAzB,CACIE,MAAQzB,IAAAyB,MADZ,CAEI5F,cAAgBA,QAAS,EAAG,CAE9B,IAAI6F,UAAY,EAAhB,CAGIC,MAAS,EAHb,CAII7N,OAASkN,SAAAlN,OACb,IAAI,CAACA,MAAL,CACE,MAAO,EAGT,KADA,IAAIoI,OAAS,EACb,CAAO,EAAEyF,KAAT,CAAiB7N,MAAjB,CAAA,CAAyB,CACnB8N,IAAAA,aAAYC,MAAA,CAAOb,SAAA,CAAUW,KAAV,CAAP,CAChB,IACE,CAACG,QAAA,CAASF,YAAT,CADH,EAEc,CAFd,CAEEA,YAFF,EAGc,OAHd,CAGEA,YAHF,EAIEH,KAAA,CAAMG,YAAN,CAJF,GAIuBA,YAJvB,CAME,KAAMG,WAAA,CAAW,sBAAX,CAAoCH,YAApC,CAAN,CAEF,GAAiB,KAAjB,EAAIA,YAAJ,CACEF,SAAA/H,KAAA,CAAeiI,YAAf,CADF,KAEO,CAELA,YAAA,EAAa,KACb,KAAAI,eAAiBJ,YAAjBI,EAA8B,EAA9BA,EAAoC,KACpCC,aAAA,CAAgBL,YAAhB;AAA4B,IAA5B,CAAqC,KACrCF,UAAA/H,KAAA,CAAeqI,aAAf,CAA8BC,YAA9B,CALK,CAOP,GAAIN,KAAJ,CAAY,CAAZ,GAAkB7N,MAAlB,EA7BaoO,KA6Bb,CAA4BR,SAAA5N,OAA5B,CACEoI,MACA,EADUsF,kBAAAvL,MAAA,CAAyB,IAAzB,CAA+ByL,SAA/B,CACV,CAAAA,SAAA5N,OAAA,CAAmB,CArBE,CAwBzB,MAAOoI,OAnCuB,CAsC5B/G,OAAA6B,eAAJ,CACE7B,MAAA6B,eAAA,CAAsB4E,MAAtB,CAA8B,eAA9B,CAA+C,CAC7ChC,MAAOiC,aADsC,CAE7CtE,aAAc,CAAA,CAF+B,CAG7CnB,SAAU,CAAA,CAHmC,CAA/C,CADF,CAOEwF,MAAAC,cAPF,CAOyBA,aAhDd,CAAZ,EAx+CY,CAAf,CAAD,CA4hDqB,WAAnB,GAAA,MAAOxI,QAAP,CAAiC,IAAAE,IAAjC,CAA4C,EAA5C,CAAiDF,OA5hDnD,CAF2F;",
"sources":["node_modules/sax/lib/sax.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$sax$lib$sax\"] = function(global,require,module,exports) {\nvar Buffer = require('buffer').Buffer;\n;(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'opentagstart',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  var Stream\n  try {\n    Stream = require('stream').Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream (strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream (strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder\n        this._decoder = new SD('utf8')\n      }\n      data = this._decoder.write(data)\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  function isWhitespace (c) {\n    return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t'\n  }\n\n  function isQuote (c) {\n    return c === '\"' || c === '\\''\n  }\n\n  function isAttribEnd (c) {\n    return c === '>' || isWhitespace(c)\n  }\n\n  function isMatch (regex, c) {\n    return regex.test(c)\n  }\n\n  function notMatch (regex, c) {\n    return !isMatch(regex, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // \u003c!--\n    COMMENT_ENDING: S++, // \u003c!-- blah -\n    COMMENT_ENDED: S++, // \u003c!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line +\n        '\\nColumn: ' + parser.column +\n        '\\nChar: ' + parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n    emitNode(parser, 'onopentagstart', tag)\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function charAt (chunk, i) {\n    var result = ''\n    if (i < chunk.length) {\n      result = chunk.charAt(i)\n    }\n    return result\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    if (typeof chunk === 'object') {\n      chunk = chunk.toString()\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = charAt(chunk, i++)\n      parser.c = c\n\n      if (!c) {\n        break\n      }\n\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = charAt(chunk, i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c\n          if (c === ']') {\n            parser.state = S.DOCTYPE\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow \u003c!-- blah -- bloo --\u003e in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (isWhitespace(c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue\n          } else if (isQuote(c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            strictFail(parser, 'Unquoted attribute value')\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            parser[buffer] += parseEntity(parser)\n            parser.entity = ''\n            parser.state = returnState\n          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint)\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xD800\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    }())\n  }\n})(typeof exports === 'undefined' ? this.sax = {} : exports)\n\n};"],
"names":["shadow$provide","global","require","module","exports","Buffer","sax","SAXParser","strict","opt","i","l","buffers","length","parser","q","c","bufferCheckPosition","MAX_BUFFER_LENGTH","lowercase","lowercasetags","looseCase","tags","closed","closedRoot","sawRoot","tag","error","noscript","state","S","BEGIN","ENTITIES","strictEntities","Object","create","XML_ENTITIES","attribList","xmlns","ns","rootNS","trackPosition","position","line","column","data","SAXStream","Stream","apply","_parser","readable","writable","me","onend","this._parser.onend","emit","onerror","this._parser.onerror","er","_decoder","streamWraps","forEach","ev","defineProperty","get","set","h","removeAllListeners","on","enumerable","configurable","isWhitespace","isQuote","emitNode","nodeType","textNode","closeText","textopts","text","trim","normalize","replace","Error","end","strictFail","BEGIN_WHITESPACE","TEXT","call","message","qname","name","attribute","qualName","indexOf","split","prefix","local","attrib","attribName","attributes","hasOwnProperty","qn","attribValue","XML_NAMESPACE","XMLNS_NAMESPACE","parent","push","value","openTag","selfClosing","tagName","uri","JSON","stringify","keys","p","nv","a","isSelfClosing","toLowerCase","SCRIPT","closeTag","script","t","closeTo","close","s","pop","n","parseEntity","entity","entityLC","numStr","charAt","slice","num","parseInt","toString","isNaN","String","fromCodePoint","beginWhiteSpace","OPEN_WAKA","startTagPosition","chunk","result","sax.parser","createStream","EVENTS","Object.create","o","F","prototype","newf","Object.keys","write","starti","substring","TEXT_ENTITY","SCRIPT_ENDING","CLOSE_TAG","SGML_DECL","sgmlDecl","nameStart","test","OPEN_TAG","PROC_INST","procInstName","procInstBody","Array","join","toUpperCase","CDATA","cdata","COMMENT","comment","DOCTYPE","doctype","SGML_DECL_QUOTED","DOCTYPE_DTD","DOCTYPE_QUOTED","DOCTYPE_DTD_QUOTED","COMMENT_ENDING","COMMENT_ENDED","CDATA_ENDING","CDATA_ENDING_2","PROC_INST_ENDING","PROC_INST_BODY","body","nameBody","OPEN_TAG_SLASH","ATTRIB","ATTRIB_NAME","ATTRIB_VALUE","ATTRIB_NAME_SAW_WHITE","ATTRIB_VALUE_QUOTED","ATTRIB_VALUE_UNQUOTED","ATTRIB_VALUE_ENTITY_Q","ATTRIB_VALUE_CLOSED","ATTRIB_VALUE_ENTITY_U","CLOSE_TAG_SAW_WHITE","returnState","buffer","regex","entityBody","entityStart","maxAllowed","Math","max","maxActual","len","resume","flush","ex","filter","constructor","SAXStream.prototype.write","isBuffer","StringDecoder","SAXStream.prototype.end","SAXStream.prototype.on","handler","args","arguments","splice","xml","STATE","COMMENT_STARTING","key","e","fromCharCode","stringFromCharCode","floor","codeUnits","index","codePoint","Number","isFinite","RangeError","highSurrogate","lowSurrogate","MAX_SIZE"]
}
