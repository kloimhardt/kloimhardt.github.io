{"version":3,"sources":["sci/core.cljc"],"mappings":"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","names":["var_args","G__27835","sci.core/new-var","js/Error","name","G__27836","sci.core.new_var.cljs$core$IFn$_invoke$arity$3","sci.impl.vars/unbind","val","cljs.core/meta","init-val","meta","sci.impl.vars/SciVar","G__27848","sci.core/new-dynamic-var","G__27849","sci.core.new_dynamic_var.cljs$core$IFn$_invoke$arity$3","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","sci.core/in","sci.impl.io/in","sci.core/out","sci.impl.io/out","sci.core/err","sci.impl.io/err","args__4795__auto__","len__4789__auto__","i__4790__auto__","argseq__4796__auto__","cljs.core/IndexedSeq","sci.core/alter-var-root","seq27876","G__27877","cljs.core/first","cljs.core/next","G__27878","self__4776__auto__","v","f","args","cljs.core.apply.cljs$core$IFn$_invoke$arity$4","sci.impl.vars/alter-var-root","G__27880","sci.core/eval-string","s","sci.core.eval_string.cljs$core$IFn$_invoke$arity$2","opts","sci.impl.interpreter.eval_string.cljs$core$IFn$_invoke$arity$2"],"sourcesContent":["(ns sci.core\n  (:refer-clojure :exclude [with-bindings with-in-str with-out-str\n                            with-redefs binding future pmap alter-var-root])\n  (:require\n   [sci.impl.interpreter :as i]\n   [sci.impl.vars :as vars]\n   [sci.impl.io :as sio]\n   [sci.impl.macros :as macros])\n  #?(:cljs (:require-macros [sci.core :refer [with-bindings with-out-str]])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(defn new-var\n  \"Alpha! Returns a new sci var. API subject to change.\"\n  ([name] (doto (new-var name nil nil)\n            (vars/unbind)))\n  ([name val] (new-var name val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar. init-val name meta)))\n\n(defn new-dynamic-var\n  \"Alpha! Same as new-var but adds :dynamic true to meta. API subject to\n  change.\"\n  ([name] (doto (new-dynamic-var name nil nil)\n            (vars/unbind)))\n  ([name init-val] (new-dynamic-var name init-val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar. init-val name (assoc meta :dynamic true))))\n\n;; (defn set-var-root!\n;;   \"Alpha! Sets root of sci var. API subject to change.\"\n;;   [sci-var root-val]\n;;   (vars/bindRoot sci-var root-val))\n\n(macros/deftime\n  (defmacro with-bindings\n    \"Macro for binding sci vars. Must be called with map of sci dynamic\n  vars to values. Used in babashka.\"\n    [bindings-map & body]\n    `(let [bm# ~bindings-map]\n       (assert (map? bm#))\n       (vars/push-thread-bindings bm#) ;; important: outside try\n       (try\n         (do ~@body)\n         (finally (vars/pop-thread-bindings)))))\n\n  (defmacro binding\n    \"Macro for binding sci vars. Must be called with a vector of sci\n  dynamic vars to values.\"\n    [bindings & body]\n    (assert (vector? bindings))\n    `(with-bindings ~(apply hash-map bindings)\n       (do ~@body)))\n\n  #_(defmacro with-redefs\n    \"Temporarily redefines sci vars while executing the body. The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its Var. After the body is\n  executed, the root values of all the sci vars will be set back to\n  their old values.  These temporary changes will be visible in all\n  threads.  Useful for mocking out functions during testing.\"\n    [bindings & body]\n    (assert (vector? bindings))\n    (let [binding-map (apply hash-map bindings)]\n      `(let [root-bind# (fn [m#]\n                          (doseq [[a-var# a-val#] m#]\n                            (vars/bindRoot a-var# a-val#)))\n             bm# ~binding-map\n             ks# (keys bm#)\n             _# (doseq [k# ks#]\n                  (assert (sci.impl.vars/var? k#) (str k# \" is not a var.\")))\n             old-vals# (zipmap ks#\n                               (map #(vars/getRawRoot %) ks#))]\n         (try\n           (root-bind# bm#)\n           (do ~@body)\n           (finally\n             (root-bind# old-vals#)))))))\n\n(def in \"Sci var that represents sci's `clojure.core/*in*`\" sio/in)\n(def out \"Sci var that represents sci's `clojure.core/*out*`\" sio/out)\n(def err \"Sci var that represents sci's `clojure.core/*err*`\" sio/err)\n\n(macros/deftime\n  (defmacro with-in-str\n    \"Evaluates body in a context in which sci's *in* is bound to a fresh\n  StringReader initialized with the string s.\"\n    [s & body]\n    `(let [in# (-> (java.io.StringReader. ~s)\n                   (clojure.lang.LineNumberingPushbackReader.))]\n       (with-bindings {in in#}\n         (do ~@body)))))\n\n(macros/deftime\n  (defmacro with-out-str\n    \"Evaluates exprs in a context in which sci's *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.\"\n    [& body]\n    `(let [out# (macros/? :clj (java.io.StringWriter.)\n                          :cljs (goog.string/StringBuffer.))]\n       (with-bindings {out out#}\n         (do ~@body)\n         (str out#)))))\n\n(macros/deftime\n  (defmacro future\n    \"Like clojure.core/future but also conveys sci bindings to the thread.\"\n    [& body]\n    `(let [f# (-> (fn [] ~@body)\n                  (vars/binding-conveyor-fn))]\n       (future-call f#))))\n\n#?(:clj (defn pmap\n          \"Like clojure.core/pmap but also conveys sci bindings to the threads.\"\n          ([f coll]\n           (let [n (+ 2 (.. Runtime getRuntime availableProcessors))\n                 rets (map #(future (f %)) coll)\n                 step (fn step [[x & xs :as vs] fs]\n                        (lazy-seq\n                         (if-let [s (seq fs)]\n                           (cons (deref x) (step xs (rest s)))\n                           (map deref vs))))]\n             (step rets (drop n rets))))\n          ([f coll & colls]\n           (let [step (fn step [cs]\n                        (lazy-seq\n                         (let [ss (map seq cs)]\n                           (when (every? identity ss)\n                             (cons (map first ss) (step (map rest ss)))))))]\n             (pmap #(apply f %) (step (cons coll colls)))))))\n\n(defn alter-var-root\n  \"Atomically alters the root binding of sci var v by applying f to its\n  current value plus any args.\"\n  [v f & args]\n  (apply vars/alter-var-root v f args))\n\n(defn eval-string\n  \"Evaluates string `s` as one or multiple Clojure expressions using the Small Clojure Interpreter.\n\n  The map `opts` may contain the following:\n\n  - `:bindings`: a map of symbols to values, e.g.: `{'x 1}`. The\n  symbols will acts as names bound to the corresponding values in the\n  expressions.\n\n  - `:namespaces`: a map of symbols to namespaces, where a namespace\n  is a map with symbols to values, e.g.: `{'foo.bar {'x 1}}`. These\n  namespaces can be used with `require`.\n\n  - `:allow`: a seqable of allowed symbols. All symbols, even those\n  brought in via `:bindings` or `:namespaces` have to be explicitly\n  enumerated.\n\n  - `:deny`: a seqable of disallowed symbols, e.g.: `[loop quote\n  recur]`.\n\n  - `:realize-max`: integer; when provided, program may realize a\n  maximum number of elements from sequences, e.g. `(vec (range))` will\n  throw for any number. This also applies to sequences returned from\n  the expression to the caller.\n\n  - `:preset`: a pretermined set of options. Currently only\n  `:termination-safe` is supported, which will set `:realize-max` to\n  `100` and disallows the symbols `loop`, `recur` and `trampoline`.\n\n  - `:features`: when provided a non-empty set of keywords, sci will process reader conditionals using these features (e.g. #{:bb}).\n\n  - `:env`: an atom with a map in which state from the\n  evaluation (defined namespaced and vars) will be persisted for\n  re-use over multiple calls.\n  \"\n  ([s] (eval-string s nil))\n  ([s opts]\n   (i/eval-string s opts)))\n\n;;;; Scratch\n\n(comment\n  (eval-string \"(inc x)\" {:bindings {'x 2}})\n  )\n"]}