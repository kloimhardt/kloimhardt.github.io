{"version":3,"sources":["tubax/core.cljs"],"mappings":"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","names":["tubax.core/new-document","tubax.core/add-node-document","node","document","keytag","cljs.core.keyword.cljs$core$IFn$_invoke$arity$1","att-map","cljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$variadic","node-value","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","tubax.core/close-node-document","cljs.core/empty?","cljs.core/rest","current-node","cljs.core/first","father-node","father-children","new-father","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","tubax.core/add-text","text","node-children","new-node-value","tubax.core/format-document","var_args","G__30653","tubax.core/xml->clj","js/Error","p__30654","map__30655","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$3","cljs.core.get.cljs$core$IFn$_invoke$arity$2","source","tubax.core.xml__GT_clj.cljs$core$IFn$_invoke$arity$2","strict","trim","normalize","lowercase","xmlns","position","strict-entities","parser","js/sax","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","result","p1__30647#","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","p1__30648#","p1__30649#","p1__30650#","cljs.core/deref","cljs.core/reset!","p1__30651#","or__4185__auto__","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2","cljs.core/List"],"sourcesContent":["(ns tubax.core\n  (:require ext.saxjs))\n\n(defn- new-document []\n  (list))\n\n(defn- add-node-document\n  [node document]\n  (let [keytag (keyword (.-name node))\n        att-map (js->clj (.-attributes node) :keywordize-keys true)\n        node-value {:tag keytag :attributes att-map :content []}]\n    (-> document (conj node-value))))\n\n(defn- close-node-document\n  [node document]\n  (if (not (empty? (rest document)))\n    (let [current-node    (first document)\n          father-node     (first (rest document))\n          father-children (:content father-node)\n          new-father (assoc father-node :content (conj father-children current-node))]\n      (conj (rest (rest document)) new-father))\n    document))\n\n(defn- add-text\n  [text document]\n  (if (not (empty? text))\n    (let [current-node (first document)\n          node-children (:content current-node)\n          new-node-value (assoc current-node :content (conj node-children text))]\n      (conj (rest document) new-node-value))\n    document))\n\n(defn- format-document\n  [document]\n  (first document))\n\n(defn xml->clj\n  ([source] (xml->clj source {}))\n  ([source {:keys [strict trim normalize\n                   lowercase xmlns position\n                   strict-entities]\n            :or {strict true\n                 trim true\n                 normalize false\n                 lowercase true\n                 position true\n                 strict-entities false}}]\n   (let [parser (.parser js/sax strict #js {\"trim\" trim\n                                            \"normalize\" normalize\n                                            \"lowercase\" lowercase\n                                            \"xmlns\" xmlns\n                                            \"position\" position\n                                            \"strictEntities\" strict-entities})\n         document (atom (new-document))\n         result (atom nil)]\n     ;; OPEN TAG\n     (set! (.-onopentag parser)\n           #(swap! document (partial add-node-document %)))\n\n     ;; CLOSE TAG\n     (set! (.-onclosetag parser)\n           #(swap! document (partial close-node-document %)))\n\n     ;; GET TEXT\n     (set! (.-ontext parser)\n           #(swap! document (partial add-text %)))\n\n     ;; CDATA HANDLING\n     (set! (.-oncdata parser)\n           #(swap! document (partial add-text %)))\n\n     ;; END PARSING\n     (set! (.-onend parser)\n           #(when (nil? @result)\n              (reset! result {:success (format-document @document)})))\n\n     ;; ERROR\n     (set! (.-onerror parser)\n           #(reset! result {:error (str %)}))\n\n     (.write parser source)\n     (.close parser)\n\n     (or (:success @result)\n         (throw (ex-info (str (:error @result)) {}))))))\n"]}